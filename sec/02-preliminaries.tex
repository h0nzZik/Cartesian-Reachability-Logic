\section{Preliminaries}

\subsection{($\mu$-free) Matching Logic}

We work with a variant of matching logic described in
\cite{StefanescuCMMSR19,RosuSCM13lics}.
This particular variant of matching logic is used for reasoning about static properties of program configurations.
There exist newer and more expressive variants of matching logic (\cite{MmL, MLexplained});
we used the older variant in order to be compatible with the literature on reachability logic which uses this variant.

Matching logic \emph{formula} (aka \emph{pattern}) is a first-order logic (FOL) formula which allows terms,
over a signature $\Sigma$, with variables, as nullary predicates.
A typical example of a matching logic formula is $\varphi_{\mathit{example}}$, defined as
\begin{equation}\label{eqn:exampleMLPattern}
\texttt{<k> x--; <k><st> x} \texttt{ |-> } X\texttt{ </st>} \land (X \texttt{ >Int } 1 = \mathit{true})
\end{equation}
which, when interpreted in a model of a particular programming language,
denotes the set of program configurations in which the code \texttt{x--} is to be executed
and in which the program variable $\texttt{x}$ has a value $X$ that is greater than $1$.
In this example, the part $\texttt{<k> x--; <k><st> x} \texttt{ |-> } X\texttt{ </st>}$
is the term-as-predicate, with $X$ being the only free FOL variable.
The program variable $\texttt{x}$ is not a FOL variable, but a constant symbol from the signature of the programming language.
The subterm $\texttt{x} \texttt{ |-> } X\texttt{ </st>}$ says that the program variable $\texttt{x}$
has the value $X$, and the $X \texttt{ >Int } 1 = \mathit{true}$ part then says that the realization
of the function symbol $\_ \texttt{ >Int } \_$ returns the boolean value $\mathit{true}$ when given $X$ and $1$
as arguments.

The satisfaction relation $(M, \gamma, \rho) \vDash \varphi$ between a model $M$, a model element $\gamma \in M$,
an $M$-valuation $\rho$, and a pattern $\varphi$, is defined inductively on the structure of $\varphi$.
The definition is as in FOL; the main difference is the semantics of terms-as-predicates, which is defined by
\begin{equation*}
    (M, \gamma, \rho) \vDash t \iff \gamma = \rho(t) \text{ if t is a term}
\end{equation*}
(where $\rho(t)$ is the homomorphic extension of $\rho$ applied to the term $t$).
For example, we might have a matching logic model $M$ containing (concrete) program configurations
of a particular programming language.
One such configuration might be $\gamma_{\mathit{example}}$:
\begin{equation*}
    \texttt{<k> x--; <k><st> x} \texttt{ |-> } 3\texttt{ </st>} \, .
\end{equation*}
Then, we have that $(M, \gamma_{\mathit{example}}, \rho) \vDash \varphi_{\mathit{example}}$
for any valuation $\rho$ satisfying $\rho(X) = 3$, and we say that
$\varphi_{\mathit{example}}$ \emph{matches} $\gamma_{\mathit{example}}$ in $\rho$.


A pattern $\varphi$ is \emph{valid in $M$}, written $M \vDash \varphi$, iff $(M, \gamma, \rho) \vDash \varphi$
for every $\gamma$ and $\rho$.
We observe that validity of a structureless pattern (that is a pattern without terms-as-predicates) does not depend on the selected model element.
Also, validity of any pattern does not depend on those variables which the pattern does not mention.
A more formal treatment of matching logic is to be found in the Appendix.


\subsection{One-path Reachability Logic}
Reachability logic \cite{StefanescuCMMSR19,RosuS12oopsla} (RL) is a formalism for
defining formal semantics of programming languages,
and also for specifying and reasoning about partial correctness properties
of programs in those languages.
On the formal semantics side, a programming language is modelled as a \emph{reachability system}
$\mathcal{S} = (\mathcal{T}, S)$, where $\mathcal{T}$ is a $\Sigma$-algebra
and $S$ is a set of \emph{reachability rules} of the shape $\varphi \Rightarrow^\exists \varphi^\prime$,
where $\varphi$ and $\varphi^\prime$ are matching logic patterns over $\Sigma$.
For example, one can have a rule
\begin{equation}\label{eqn:ruleIfTrue}
    \begin{aligned}
    & \texttt{<k> if (} \mathit{true} \texttt{) }P_1\texttt{ else } P_2 \texttt{</k><st>} S \texttt{</st>} \\
    & \Rightarrow \texttt{<k> }P_1 \texttt{</k><st>} S \texttt{</st>}
    \end{aligned}
\end{equation}
saying that the \texttt{if} construct of the particular language takes the first branch ($P_1$)
whenever the condition is $\mathit{true}$.
(Typically, there would be another rules governing evaluation of the condition.)

The meaning of reachability rules is the following.
A reachability system $\mathcal{S} = (\mathcal{T}, S)$ (together with a $\Sigma$-sort $\mathit{Cfg}$)
induces
a \emph{transition system}
$(\Tcfg , \Rightarrow_{\mathcal{S}})$,
where $\gamma \Rightarrow_{\mathcal{S}} \gamma^\prime$
for $\gamma, \gamma^\prime \in \Tcfg$
iff there is some rule $\varphi \Rightarrow^\exists \varphi^\prime \in S$
and some valuation $\rho : \Var \to \mathcal{T}$ with $(\gamma, \rho) \vDash \varphi$
and $(\gamma^\prime , \rho) \vDash \varphi^\prime$.
The intuition is that when taking a transition in the resulting transition system,
some rule $\varphi \Rightarrow^\exists \varphi^\prime \in S$ is selected,
then the current configuration is pattern-matched against the rule's left-side pattern $\varphi$,
resulting in a valuation $\rho$ which is then used to instantiate the right-side $\varphi^\prime$ of the rule,
forming a new configuration.
For example, the rule in \Cref{eqn:ruleIfTrue} induces (among others) the transition
\begin{equation}\label{eqn:ruleIfTrue}
    \begin{aligned}
    & \texttt{<k> if (} \mathit{true} \texttt{) x++; else x--; </k><st>x} \texttt{ |-> } 3\texttt{</st>} \\
    & \Rightarrow_{\mathcal{S}} \texttt{<k> x++; </k><st>x} \texttt{ |-> } 3\texttt{</st>} \, .
    \end{aligned}
\end{equation}

On the partial correctness side, RL reuses the notion of a \emph{reachability rule}.
For example, one can specify that the program \texttt{while(x > 0) x--;}
can, if it terminates at all, reach a configuration
where the program variable \texttt{x} has a non-positive value
by means of the reachability rule
\begin{equation*}
    \begin{aligned}
        & \texttt{<k> while( x > 0 ) x--; </k> <st> x |-> } V \texttt{</st>} \\
        & \Rightarrow^\exists \exists V^\prime.\, \texttt{<k> . </k> x |-> } V^\prime \texttt{</st>} \land (V^\prime \texttt{ <=Int } 0 = \mathit{true})
    \end{aligned}
\end{equation*}
Assuming the language is deterministic, this is equivalent to saying that if the program terminates,
the resulting configuration will have non-positive value of \texttt{x}.
Formally, a rule of the shape $\varphi \Rightarrow^\exists \varphi^\prime$
is \emph{satisfied}
in a reachability system $\mathcal{S} = (\mathcal{T}, S)$,
written $\mathcal{S} \vDash_\RL \varphi \Rightarrow^\exists \varphi^\prime$,
iff for every $\gamma \in \Tcfg$
such that $\gamma$ terminates in $(\Tcfg, \Rightarrow_{\mathcal{S}})$
and for any valuation $\rho : \Var \to \mathcal{T}$
such that $(\gamma, \rho) \vDash \varphi$,
there exists some $\gamma^\prime \in \Tcfg$
such that
$\gamma \Rightarrow^{*}_{\mathcal{S}} \gamma^\prime$
and $(\gamma^\prime, \rho) \vDash \varphi^\prime$.


Reachability logic is equipped with a proof system which derives sequents of the shape
$\mathcal{S}, A, C \vdash_\RL \varphi \Rightarrow^\exists \varphi^\prime$;
the proof system is sound and complete: a RL claim is satisfied in $\mathcal{S}$
iff $\mathcal{S}, \emptyset, \emptyset \vdash_\RL \varphi \Rightarrow^\exists \varphi^\prime$.


\begin{remark}\label{rem:shapeOfReachabilityRules}
For simplicity, we restrict the class of reachability systems we work with to those whose reachability rules
have the shape
\begin{equation*}
    \phi \land P \Rightarrow^\exists \phi^\prime \land P^\prime
\end{equation*}
where $\phi \land P$ and $\phi^\prime \land P^\prime$ are constrained terms.
\end{remark}

\begin{remark}\label{rem:noEmptySteps}
We work only with $\epsilon$-free reachability systems.
A reachability system $(\mathcal{T}, S)$ is \emph{$\epsilon$-free}
iff for any two configurations $\sigma, \sigma^\prime \in \mathcal{T}_{\mathit{Cfg}}$, if
$\sigma \Rightarrow_{\mathcal{S}} \sigma^\prime$, then $\sigma \not = \sigma^\prime$;
\end{remark}