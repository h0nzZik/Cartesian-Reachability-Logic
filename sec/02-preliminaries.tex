\section{Preliminaries}

%\subsection{$k$-safety hyperproperties}

\subsection{Cartesian Hoare logic}

Introduced in~\cite{SousaD16}, Cartesian Hoare logic is a formalism for specifying and reasoning about
a class of hyperproperties known as \emph{$k$-safety hyperproperties}, or simply
\emph{$k$-safety properties}.
A $k$-safety property is a hyperproperty whose violation can be witnessed by a $k$-tuple of execution traces.
Many \emph{security policies} - for example, noninterference (requiring that sensitive or privileged data
do not influence insensitive or unprivileged computations) - are $k$-safety hyperproperties.
Similarly, many functional correctness properties are actually $k$-safety hyperproperties;
for example, \emph{transitivity} (which needs to by satisfied e.g. by comparators when managing data
in collections), associativity (important in the map/reduce paradigm), or monotonicity.
Cartesian Hoare logic (CHL) can be used for reasoning about these on the level of the source code,
similarly to Hoare logic.

In a Hoare logic, one specifies safety properties by means of so-called \emph{Hoare triples}.
These have the shape $\{ \varphi \} S \{ \psi \}$, with the meaning that
the formula $\psi$ holds in any state after the termination (if any) of the program $S$,
executed from a state satisfying $\varphi$.
In Cartesian Hoare logic, the situation is similar: one can specify a triple
$\langle \Phi \rangle (S_1 * \cdots * S_k) \langle \Psi \rangle$
with the following meaning: for any $k$-tuple $(\sigma_1,\ldots,\sigma_k)$ of states
satisfying the formula $\Phi$, if we execute each program $S_i$ in the respective state $\sigma_i$ and they all terminate,
then the $k$-tuple $(\sigma_1^\prime,\ldots,\sigma_k^\prime)$ of resulting program states satisfies $\Psi$ \footnote{An
important technical assumption here is that every program $S_i$ operates on its own set of program variables,
distinct from variables of other programs $S_j$ (for $i \not = j$) - otherwise the formulas $\Phi$ and $\Psi$
would not be able to distinguish between program variables of different programs.}.
%To make specifications more compact, one can also consider triples $|| \Phi ||\ S \ || \Psi ||$ 

As an example, consider the program $P(x,y) \equiv \texttt{while(x > 0) \{ x--; y++; \} }$ and the 2-safety property
of \emph{monotonicity}; that is, intuitively: with growing input $x$, the resulting $y$ also grows.
In CHL, this can be formalized as
\begin{equation*}
\langle x_1 \leq x_2 \land y_1 = y_2  \rangle (P(x_1, y_1) * P(x_2, y_2)) \langle y_1 \leq y_2 \rangle \, .
\end{equation*}
The main idea here is that the formulas can \emph{relate} variables from different executions.

Cartesian Hoare logic is equipped with a proof system that allows one to prove validity of CHL triples.
The proof system contains rules like
\begin{align*}
    & \prftree[l]{If}
      { \prfStackPremises
        { \langle \Phi \land c \rangle (\texttt{B1; S}) * R \langle \Psi \rangle }
        { \langle \Phi \land \neg c \rangle (\texttt{B2; S}) * R \langle \Psi \rangle }
      }
      { \langle \Phi \rangle (\texttt{if (c) {B1} {B2} ; S}) * R \langle \Psi \rangle }
\end{align*}
that replicate standard Hoare-logic reasoning, and is sound and complete.
However, what is even more interesting, the proof system has rules that enable \emph{lockstep reasoning}.

TODO

\subsection{($\mu$-free) Matching Logic}

We work with a variant of matching logic described in
\cite{StefanescuCMMSR19,RosuSCM13lics}.
This particular variant of matching logic is used for reasoning about static properties of program configurations.
There exist newer and more expressive variants of matching logic (\cite{MmL, MLexplained});
we used the older variant in order to be compatible with the literature on reachability logic which uses this variant.

Matching logic \emph{formula} (aka \emph{pattern}) is a first-order logic (FOL) formula which allows terms,
over a signature $\Sigma$, with variables, as nullary predicates.
A typical example of a matching logic formula is $\varphi_{\mathit{example}}$, defined as
\begin{equation}\label{eqn:exampleMLPattern}
\texttt{<k> x--; <k><st> x} \texttt{ |-> } X\texttt{ </st>} \land (X \texttt{ >Int } 1 = \mathit{true})
\end{equation}
which, when interpreted in a model of a particular programming language,
denotes the set of program configurations in which the code \texttt{x--} is to be executed
and in which the program variable $\texttt{x}$ has a value $X$ that is greater than $1$.
In this example, the part
\begin{equation*}
    \texttt{<k> x--; <k><st> x} \texttt{ |-> } X\texttt{ </st>}
\end{equation*}
is the term-as-predicate, with $X$ being the only free FOL variable.
The program variable $\texttt{x}$ is not a FOL variable, but a constant symbol from the signature of the programming language.
The subterm $\texttt{x} \texttt{ |-> } X\texttt{ </st>}$ says that the program variable $\texttt{x}$
has the value $X$, and the $X \texttt{ >Int } 1 = \mathit{true}$ part then says that the realization
of the function symbol $\_ \texttt{ >Int } \_$ returns the boolean value $\mathit{true}$ when given $X$ and $1$
as arguments.

The satisfaction relation $(M, \gamma, \rho) \vDash \varphi$ between a model $M$, a model element $\gamma \in M$,
an $M$-valuation $\rho$, and a pattern $\varphi$, is defined inductively on the structure of $\varphi$.
The definition is as in FOL; the main difference is the semantics of terms-as-predicates, which is defined by
\begin{equation*}
    (M, \gamma, \rho) \vDash t \iff \gamma = \rho(t) \text{ if t is a term}
\end{equation*}
(where $\rho(t)$ is the homomorphic extension of $\rho$ applied to the term $t$).
For example, we might have a matching logic model $M$ containing (concrete) program configurations
of a particular programming language.
One such configuration might be $\gamma_{\mathit{example}}$:
\begin{equation*}
    \texttt{<k> x--; <k><st> x} \texttt{ |-> } 3\texttt{ </st>} \, .
\end{equation*}
Then, we have that $(M, \gamma_{\mathit{example}}, \rho) \vDash \varphi_{\mathit{example}}$
for any valuation $\rho$ satisfying $\rho(X) = 3$, and we say that
$\varphi_{\mathit{example}}$ \emph{matches} $\gamma_{\mathit{example}}$ in $\rho$.


A pattern $\varphi$ is \emph{valid in $M$}, written $M \vDash \varphi$, iff $(M, \gamma, \rho) \vDash \varphi$
for every $\gamma$ and $\rho$.
We observe that validity of a structureless pattern (that is a pattern without terms-as-predicates) does not depend on the selected model element.
Also, validity of any pattern does not depend on those variables which the pattern does not mention.
A more formal treatment of matching logic is to be found in the Appendix.


\subsection{One-path Reachability Logic}
Reachability logic \cite{RosuS12oopsla, StefanescuCMMSR19} (RL) is a formalism for
defining formal semantics of programming languages,
and also for specifying and reasoning about partial correctness properties
of programs in those languages.
On the formal semantics side, a programming language is modelled as a \emph{reachability system}
$\mathcal{S} = (\mathcal{T}, S)$, where $\mathcal{T}$ is a $\Sigma$-algebra
and $S$ is a set of \emph{reachability rules} of the shape $\varphi \Rightarrow^\exists \varphi^\prime$,
where $\varphi$ and $\varphi^\prime$ are matching logic patterns over $\Sigma$.
For example, one can have a rule
\begin{equation}\label{eqn:ruleIfTrue}
    \begin{aligned}
    & \texttt{<k> if (} \mathit{true} \texttt{) }P_1\texttt{ else } P_2 \texttt{</k><st>} S \texttt{</st>} \\
    & \Rightarrow \texttt{<k> }P_1 \texttt{</k><st>} S \texttt{</st>}
    \end{aligned}
\end{equation}
saying that the \texttt{if} construct of the particular language takes the first branch ($P_1$)
whenever the condition is $\mathit{true}$.
(Typically, there would be another rules governing evaluation of the condition.)

The meaning of reachability rules is the following.
A reachability system $\mathcal{S} = (\mathcal{T}, S)$ (together with a $\Sigma$-sort $\mathit{Cfg}$)
induces
a \emph{transition system}
$(\Tcfg , \Rightarrow_{\mathcal{S}})$,
where $\gamma \Rightarrow_{\mathcal{S}} \gamma^\prime$
for $\gamma, \gamma^\prime \in \Tcfg$
iff there is some rule $\varphi \Rightarrow^\exists \varphi^\prime \in S$
and some valuation $\rho : \Var \to \mathcal{T}$ with $(\gamma, \rho) \vDash \varphi$
and $(\gamma^\prime , \rho) \vDash \varphi^\prime$.
The intuition is that when taking a transition in the resulting transition system,
some rule $\varphi \Rightarrow^\exists \varphi^\prime \in S$ is selected,
then the current configuration is pattern-matched against the rule's left-side pattern $\varphi$,
resulting in a valuation $\rho$ which is then used to instantiate the right-side $\varphi^\prime$ of the rule,
forming a new configuration.
For example, the rule in \Cref{eqn:ruleIfTrue} induces (among others) the transition
\begin{equation}\label{eqn:ruleIfTrue}
    \begin{aligned}
    & \texttt{<k> if (} \mathit{true} \texttt{) x++; else x--; </k><st>x} \texttt{ |-> } 3\texttt{</st>} \\
    & \Rightarrow_{\mathcal{S}} \texttt{<k> x++; </k><st>x} \texttt{ |-> } 3\texttt{</st>} \, .
    \end{aligned}
\end{equation}

On the partial correctness side, RL reuses the notion of a \emph{reachability rule}.
For example, one can specify that the program \texttt{while(x > 0) x--;}
can, if it terminates at all, reach a configuration
where the program variable \texttt{x} has a non-positive value
by means of the reachability rule
\begin{equation*}
    \begin{aligned}
        & \texttt{<k> while( x > 0 ) x--; </k> <st> x |-> } V \texttt{</st>} \\
        & \Rightarrow^\exists \exists V^\prime.\, \texttt{<k> . </k> x |-> } V^\prime \texttt{</st>} \land (V^\prime \texttt{ <=Int } 0 = \mathit{true})
    \end{aligned}
\end{equation*}
Assuming the language is deterministic, this is equivalent to saying that if the program terminates,
the resulting configuration will have non-positive value of \texttt{x}.
Formally, a rule of the shape $\varphi \Rightarrow^\exists \varphi^\prime$
is \emph{satisfied}
in a reachability system $\mathcal{S} = (\mathcal{T}, S)$,
written $\mathcal{S} \vDash_\RL \varphi \Rightarrow^\exists \varphi^\prime$,
iff for every $\gamma \in \Tcfg$
such that $\gamma$ terminates in $(\Tcfg, \Rightarrow_{\mathcal{S}})$
and for any valuation $\rho : \Var \to \mathcal{T}$
such that $(\gamma, \rho) \vDash \varphi$,
there exists some $\gamma^\prime \in \Tcfg$
such that
$\gamma \Rightarrow^{*}_{\mathcal{S}} \gamma^\prime$
and $(\gamma^\prime, \rho) \vDash \varphi^\prime$.


Reachability logic is equipped with a proof system which derives sequents of the shape
$A, C \vdash_\RL \varphi \Rightarrow^\exists \varphi^\prime$;
the proof system is sound and complete: a RL claim is satisfied in $\mathcal{S}$
iff $\mathcal{S}, \emptyset \vdash_\RL \varphi \Rightarrow^\exists \varphi^\prime$.
The set $C$, initially empty, contains so-called \emph{circularities},
which are claims postulated to hold but not justified yet.
Circularities, which correspond to the notion of \emph{loop invariants} of Hoare logic,
enable one to reason about repetetive behavior of programs.
The proof system contains a rule
\begin{align*}
    & \prftree[l]{Circularity}
      { A, C \cup \{ \varphi\Rightarrow^\exists \varphi^\prime \} \vdash_\RL \varphi \Rightarrow^\exists \varphi^\prime }
      { A, C \vdash_\RL \varphi \Rightarrow^\exists \varphi^\prime }
\end{align*}
which adds to current claim to the set of circularities.
When a progress is made (by means of other rules, essentially performing a symbolic execution),
the claim is moved from circularities to axioms and can be reused, similarly to the way one assumes a loop invariant
in order to prove it again.
We refer an interested reader to~\cite{RosuS12oopsla} for more details.


%For illustration purposes, we show one rule of the RL proof system:
%\begin{align*}
%    & \prftree[l]{Case Analysis}
%      %{ \prfStackPremises
%        { A, C \vdash_\RL \varphi_1 \Rightarrow^\exists \varphi }
%        { A, C \vdash_\RL \varphi_2 \Rightarrow^\exists \varphi }
%      %}
%      { A, C \vdash_\RL \varphi_1 \lor \varphi_2 \Rightarrow^\exists \varphi }
%\end{align*}


\begin{remark}\label{rem:shapeOfReachabilityRules}
For simplicity, we restrict the class of reachability systems we work with to those whose reachability rules
have the shape
\begin{equation*}
    \phi \land P \Rightarrow^\exists \phi^\prime \land P^\prime
\end{equation*}
where $\phi,\phi^\prime$ are terms-as-predicates, and $P,P^\prime$ contain no terms-as-predicate.
\end{remark}

\begin{remark}\label{rem:noEmptySteps}
We work only with $\epsilon$-free reachability systems.
A reachability system $(\mathcal{T}, S)$ is \emph{$\epsilon$-free}
iff for any two configurations $\sigma, \sigma^\prime \in \mathcal{T}_{\mathit{Cfg}}$, if
$\sigma \Rightarrow_{\mathcal{S}} \sigma^\prime$, then $\sigma \not = \sigma^\prime$;
\end{remark}