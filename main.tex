\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amssymb,mathtools}
\usepackage{amsthm}
\usepackage{thmtools}
\usepackage{hyperref}
% `cleveref` has to be loaded after `hyperref`
\usepackage{cleveref}
\usepackage{stackengine}
\usepackage{minted}
\usepackage{tcolorbox}
\usepackage{multicol}
\usepackage{prftree}
\usepackage{fancyvrb}
\usepackage{csquotes}
\usepackage{appendix}

\title{Cartesian Reachability Logic}
\author{Jan Tu≈°il }
\date{February 2022}

\declaretheorem[]{example}
\declaretheorem[]{definition}
\declaretheorem[]{lemma}
\declaretheorem[]{theorem}
\declaretheorem[]{remark}

\newcommand{\RL}{\mathsf{RL}}
\newcommand{\ML}{\mathsf{ML}}
\newcommand{\CRL}{\mathsf{CRL}}
\newcommand{\Var}{\mathit{Var}}
\newcommand{\Tcfg}{\mathcal{T}_{\mathit{Cfg}}}

\newcommand\oast{\stackMath\mathbin{\stackinset{c}{0ex}{c}{0ex}{\ast}{\bigcirc}}}

\begin{document}

\maketitle

\section{Introduction}

\section{Preliminaries}

\subsection{(Topmost, $\mu$-free) Matching Logic}

\subsection{All-path Reachability Logic}



\begin{definition}[\cite{StefanescuCMMSR19}]
We define reachability-logic signatures, rules, and systems as follows.
\begin{enumerate}
    \item A reachability-logic \emph{signature} is a pair $(\Sigma, \mathit{Cfg})$,
          where $\Sigma$ is a matching logic signature and $\mathit{Cfg}$ is a sort.
          
    \item A \emph{one-path reachability rule} over reachability logic signature $(\Sigma, \mathit{Cfg})$        is a pair $\varphi \Rightarrow^\exists \varphi^\prime$,
          where $\varphi$ and $\varphi^\prime$
          are patterns (which can have free variables) of sort $\mathit{Cfg}$.
          
    \item A \emph{reachability system} over a reachability-logic signature $(\Sigma, \mathit{Cfg})$
          is a pair $\mathcal{S} = (\mathcal{T}, S)$, where $\mathcal{T}$ is a $\Sigma$-algebra
          and $S$ is a set of reachability rules over $(\Sigma, \mathit{Cfg})$.
          
    \item A rule $\varphi \Rightarrow^\exists \varphi^\prime$ over $(\Sigma, \mathit{Cfg})$
          is \emph{weakly well-defined}
          with respect to $\Sigma$-algebra $\mathcal{T}$
          iff
          for any $\gamma \in \Tcfg$ and $\rho : \Var \to \mathcal{T}$
          with $(\gamma, \rho) \vDash \varphi$,
          there exists $\gamma^\prime \in \Tcfg$ with $(\gamma^\prime , \rho) \vDash \varphi^\prime$.
          
    \item A reachability system $\mathcal{S}$ is \emph{weakly well-defined} iff each its rule is weakly     
          well-defined.
          
    \item A reachability system $\mathcal{S} = (\mathcal{T}, S)$ over $(\Sigma, \mathit{Cfg})$ induces
          a \emph{transition system} \\
          $(\Tcfg , \Rightarrow_{\mathcal{S}})$,
          where $\gamma \Rightarrow_{\mathcal{S}} \gamma^\prime$
          for $\gamma, \gamma^\prime \in \Tcfg$
          iff there is some rule \\ $\varphi \Rightarrow^\exists \varphi^\prime \in S$
          and some valuation $\rho : \Var \to \mathcal{T}$ with $(\gamma, \rho) \vDash \varphi$
          and $(\gamma^\prime , \rho) \vDash \varphi^\prime$.
          
    \item A \emph{$\Rightarrow_{\mathcal{S}}$-path} is a finite
          sequence $\gamma_0 \Rightarrow_{\mathcal{S}} \gamma_1 \Rightarrow_{\mathcal{S}} \ldots \Rightarrow_{\mathcal{S}} \gamma_n$
          with $\gamma_0,\ldots,\gamma_n \in \Tcfg$.
          
    \item A $\Rightarrow_{\mathcal{S}}$-path is \emph{complete}
          iff it is not a strict prefix of any
          other $\Rightarrow_{\mathcal{S}}$-path.
\end{enumerate}

\end{definition}

\section{Cartesian Reachability Logic}

We need to make the definition such that it works with reachability logic for the composite semantics.
Here is one attempt:
\begin{definition}\label{def:CRLsemantics}
A Cartesian reachability rule
$(\varphi_1,\ldots,\varphi_k) \land \varphi \Rightarrow^{c\forall} (\psi_1,\ldots,\psi_k) \land \psi$
of arity $k$
is \emph{valid},
written
$\vDash_\CRL (\varphi_1,\ldots,\varphi_k) \land \varphi \Rightarrow^{c\forall}
(\psi_1,\ldots,\psi_k) \land \psi$,
iff for all configurations $\sigma_1,\ldots,\sigma_k$ and any valuation $\rho$,
whenever $\sigma_1 \in |\varphi_1 \land \varphi|_\rho \land \ldots \land \sigma_k \in |\varphi_l \land \varphi|_\rho$,
then for every complete (that is, finite terminating) executions $\pi_1, \ldots, \pi_k$ such that
$\sigma_1 = \pi_1(0) \land \ldots \land \sigma_k = \pi_k(0)$ there exists $i_1,\ldots,i_k \in \mathbb{N}$
such that
$\pi_1(i_1) \in |\varphi_1 \land \psi|_\rho \land \ldots \land \pi_k(i_k) \in |\varphi_k \land \psi|_\rho$.
\end{definition}

TODOs:
\begin{itemize}
    \item Validate this definition against examples from the CHL paper.
    \item Have a "running example" - some programming language, like IMP?
    \item Define the 'composite' semantics - list of configurations in one configuration.
    \item Have an example how do we perform lockstep execution on ifs.
    \item Why there are the pluses on both premises of the Circularity proof rule of the Equiv checking paper? Do we need it? Maybe we may lose/miss some synchronization point if we require both. We probably need to weaken the premises.
    \item Conservativeness argument for the additional rules.
\end{itemize}

\begin{definition}
We translate a language semantics into a semantics for lists of configurations as follows.
\begin{enumerate}
    \item Let $(\Sigma, \mathit{Cfg})$ be a reachability-logic signature.
          Then $(\Sigma, \mathit{Cfg})^*$ = $(\Sigma^*, \mathit{Cfg}^*)$,
          where
          \begin{enumerate}
              \item $\Sigma^* = \Sigma \cup \{ \mathit{cfgitem}, \mathit{cfgconcat},
          %\mathit{cfgdummy},
          \mathit{cfgheat} \}$
              \item $\mathit{Cfg}^*$ is a fresh sort (representing the sort of lists of configurations);
              %\item $\mathit{cfgdummy}$ is a fresh symbol of sort $\mathit{Cfg}$;
              \item $\mathit{cfgitem}$ a fresh symbol of sort $\mathit{Cfg} \to \mathit{Cfg}^*$;
              \item $\mathit{cfgconcat}$ a fresh symbol of sort $\mathit{Cfg}^* \times \mathit{Cfg}^* \to \mathit{Cfg}^*$; and
              \item $\mathit{cfgheat}$ is a fresh symbol of sort $\mathit{Cfg}^* \times \mathit{Cfg} \times \mathit{Cfg}^* \to \mathit{Cfg}^*$.
          \end{enumerate}
    \item Let $S$ be a set of reachability rules over $(\Sigma, \mathit{Cfg})$.
          We generate a set of reachability rules $S^*$ over $(\Sigma, \mathit{Cfg})^*$
          by setting
          \begin{equation*}
              S^* = \{ \mathit{cfgheat}(L, \varphi_1, R) \land P \Rightarrow^\exists \mathit{cfgheat}(L, \varphi_2, R) \land P^\prime \mid (\varphi_1 \land P \Rightarrow^\exists \varphi_2 \land P^\prime) \in S \} \, ,
          \end{equation*}
          where $L,R$ are distinct fresh variables (not occurring in any rule in $S$).
    \item Let $\mathcal{T}$ be a configuration model; that is, a $\Sigma$-algebra.
          We generate a $\Sigma^*$-algebra $\mathcal{T}*$, which interprets all sorts and symbols from
          $\Sigma$ as in $\mathcal{T}$, and in addition interprets
          \begin{enumerate}
              \item the sort $\mathit{Cfg}*$ as the set of all finite lists
              $[c_1;\ldots;c_n]$ for $n \in \mathbb{N}$, where $c_i$ is an element of sort $\mathit{Cfg}$
              for any $0 \leq i \leq n$;
              \item the symbol $\mathit{cfgitem}$ as the function $\lambda c.\, [c]$;
              \item the symbol $\mathit{cfgconcat}$ as the function $\lambda l_1,l_2.\, l_1 \texttt{++} l_2$,
                where $\texttt{++}$ is list concatenation; and
              \item the symbol $\mathit{cfgheat}$ as the function
                $\lambda l_1, c, l_2.\, l_1 \texttt{++} [c] \texttt{++} l_2$.
          \end{enumerate}
          
    \item Let $\mathcal{S} = (\mathcal{T}, S)$ be a reachability system over $(\Sigma, \mathit{Cfg})$.
          We generate a reachability system $\mathcal{S}^*$ over $(\Sigma, \mathit{Cfg})^*$
          by setting $\mathcal{S}^* = (\mathcal{T}^*, S^*)$.
\end{enumerate}
\end{definition}

\begin{lemma}
    Let $\mathcal{S} = (\mathcal{T}, S)$ be a reachability-logic system over $(\Sigma, \mathit{Cfg})$.
    For any $k \geq 1$, any configurations $c_1,\ldots,c_k, c^\prime \in \Tcfg$, and any $1 \leq i \leq k$,
    we have
    \begin{equation*}
        c_i \Rightarrow_{\mathcal{S}} c^\prime
                    \iff
        [c_1,\ldots,c_k] \Rightarrow_{\mathcal{S}^*} [c_1, \ldots, c_{i-1}, c^\prime, c_{i+1}, \ldots, c_k]
    \end{equation*}
\end{lemma}
\begin{proof}
Admitted.
\end{proof}


\section{Proof System}

The proof system derives claims of the shape
$\vdash_\CRL (\varphi_1 \land P_1, \ldots, \varphi_k \land P_k) \land P \Downarrow_C E$,
where $\varphi_i$ are structural patterns, and $P_i$ and $P$ are predicate patterns.
Maybe we need a constraint that $\mathit{FV}(P_i) \subseteq \mathit{FV}(\varphi_i)$.
That way we can feed the $(\varphi_i, P_i)$ component to RL without some unexpected behavior.
The idea is that $P$ is the part of the claim that relates variables from different components.
Therefore, we also probably need the Consequence rule to work with $P$, too.

\begin{figure}
    \centering
    \begin{align*}
    & \prftree[l]{Axiom}{\varphi \in E}{\vdash_\CRL \varphi \Downarrow_{C} E}   \\
    \end{align*}
    \begin{align*}
    %& \prftree[l]{Axiom}{\varphi \in E}{\varphi \Downarrow_{C} E}  \\
    & \prftree[l]{Step}
    {\vDash_\RL \varphi_i \Rightarrow^\forall \varphi_i^\prime}
    { \vdash_\CRL (\varphi_1, \ldots, \varphi_{i-1}, \varphi_i^\prime, \varphi_{i+1}, \ldots, \varphi_k)
      \land P
      \Downarrow_{\emptyset} (C \cup E)
    }
    {\vdash_\CRL (\varphi_1, \ldots, \varphi_{i-1}, \varphi_i, \varphi_{i+1}, \ldots, \varphi_k) \land P \Downarrow_{C} E}
    \end{align*}
    \begin{align*}
    & \prftree[l]{Circularity}
      { \vdash_\CRL (\varphi_1, \ldots, \varphi_k) \land P \Downarrow_{C \cup \{ (\varphi_1, \ldots, \varphi_k) \land P \} } E}
      { \vdash_\CRL (\varphi_1, \ldots, \varphi_k) \land P \Downarrow_{C} E}
      \\
    \end{align*}
    \begin{align*}
    & \prftree[l]{Conseq}
      { \prfStackPremises
        { \vdash_\CRL (\varphi_1 \land P_1, \ldots, \varphi_k \land P_k) \land P \Downarrow_{C} E}
        { \vDash_\ML \varphi_1 = \varphi_1^\prime \land \ldots \land \varphi_k = \varphi_k^\prime
        \land (P_1 \land \ldots \land P_k \land P \leftrightarrow P_1 \land \ldots \land P_k \land P) }
      }
      { \vdash_\CRL (\varphi_1^\prime \land P_1^\prime, \ldots, \varphi_k^\prime \land P_k^\prime) \land P^\prime \Downarrow_{C} E}
    \end{align*}
    \caption{Proof System}
    \label{fig:my_label}
\end{figure}

\section{Implementation}

\bibliography{bibliography}
\bibliographystyle{plain}

\appendix


\end{document}
