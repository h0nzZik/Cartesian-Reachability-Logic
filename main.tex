\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amssymb,mathtools}
\usepackage{amsthm}
\usepackage{thmtools}
\usepackage{hyperref}
% `cleveref` has to be loaded after `hyperref`
\usepackage{cleveref}
\usepackage{stackengine}
\usepackage{minted}
\usepackage{tcolorbox}
\usepackage{multicol}
\usepackage{prftree}
\usepackage{fancyvrb}
\usepackage{csquotes}
\usepackage{appendix}
\usepackage{enumitem}
\usepackage{todonotes}

\newcommand{\traian}[1]{\todo[author=Traian]{#1}}
\newcommand{\jt}[1]{\todo[author=Jan]{#1}}

\title{Cartesian Reachability Logic: A Language-Independent Logic for Verifying $k$-Safety Properties}
\author{Jan Tu\v{s}il  \and Traian Florin Șerbănuță \and Xiaohong Chen
%\and Jan Obdrzalek
}
\date{\today}

\declaretheorem[]{example}
\declaretheorem[]{definition}
\declaretheorem[]{lemma}
\declaretheorem[]{theorem}
\declaretheorem[]{remark}

\newcommand{\K}{$\mathbb{K}$}
\newcommand{\RL}{\mathsf{RL}}
\newcommand{\ML}{\mathsf{ML}}
\newcommand{\CRL}{\mathsf{CRL}}
\newcommand{\FOL}{\mathsf{FOL}}
\newcommand{\FOLeq}{\FOL_{=}}
\newcommand{\Var}{\mathit{Var}}
\newcommand{\Tcfg}{\mathcal{T}_{\mathit{Cfg}}}
\newcommand{\Pattern}{\mathsf{Pattern}}

\newcommand\oast{\stackMath\mathbin{\stackinset{c}{0ex}{c}{0ex}{\ast}{\bigcirc}}}

\newenvironment{proofenv}
  {
    \VerbatimEnvironment\begin{tcolorbox}[colback=black!0!white] % 5 is the default
  }
  {
   \end{tcolorbox}
  }

\begin{document}

\maketitle

\section{Introduction}
Recent years have witnesssed an increased interest in formal verification of \emph{hyperproperties}.
A hyperproperty is a set of \emph{sets of} execution traces, with the following semantics:
a system $S$ (a set of traces) satisfies a hyperproperty $H$ iff $S \in H$.
Hyperproperties are strictly more expressive then properties; for example, many security policies
of interest are hyperproperties but not properties.

Techniques and tools for verifying hyperproperties of (finite-state) hardware \cite{CoenenFST19,FinkbeinerRS15},
as well as (infinite-state) software systems have been developed.
For verification of software systems in particular, \emph{Cartesian Hoare logic} (CHL, \cite{SousaD16}) extends Hoare logic
to reason about \emph{$k$-safety hyperproperties}
(a hyperproperty is a \emph{$k$-safety hyperproperty} if its violation can be witnessed
by a set of traces of size $k$).
However, it is not clear how to use these techniques with arbitrary programming languages,
since CHL is tied to a particular imperative language.

On the other hand, there have been recent developments in the are of \emph{language-independent} software verification.
\emph{Reachability logic} (RL) \cite{RosuS12oopsla,RosuSCM13lics,StefanescuCMMSR19}
is a
formalism for reasoning about partial correctness of software, in the spirit of Hoare logics.
Being implemented in the \K{} framework \cite{KVision},
its biggest advantage is that reachability logic is \emph{language independent}:
its proof system can be used unchanged to reason about programs in any language,
as long as the language has a formal semantics in RL.
Therefore, researchers no longer need to think about a particular language construct three times
(once for the operational semantics, once for axiomatic, and once for the correspondence);
additionally, a single researcher or a tool-builder does not need to understand both the precise (and often intricate)
semantics of a programming language, \emph{and} formal verification techniques,
which makes \emph{division of labour} possible.
Through \K{}, reachability logic has been used to build verifiers for real-world languages,
such as C (\cite{RVMatch}), Java (\cite{StefanescuPYLR16VerifiersForAll}), Javascript (\cite{StefanescuPYLR16VerifiersForAll}),
and EVM (\cite{KevmVerificationTool}).

Can we have the best of both worlds? We think it is possible.
In this paper we develop a logic named \emph{Cartesian Reachability logic (CRL)}, which properly extends reachability logic
to allow reasoning about $k$-safety hyperproperties. Simiarly to CHL, CRL has a sound
and relatively complete proof system. A major advantage of CRL against CHL is that it works with any language
for which RL works; that is, with any language which has a RL-based formal semantics.
However, CRL does \emph{not} extend CHL, because the two logics give different semantics to properties of nondeterministic programs;
despite this distinction, CRL extends CHL on the deterministic fragment of the CHL-supported language.
We elaborate on this relation in \Cref{sec:discussion}. 

The idea behind soundness and completeness of our approach is similar to the one of \cite{SousaD16} for CHL.
We define a language-agnostic equivalent of self-composition (\cite{BartheDR11}) and establish a relation
between CRL validity of the original and RL validity of the composed system.
Then we construct a proof system such that its proofs can be translated to ordinary RL proofs of the composed system
(for soundness),
but also such that it allows relatively high-level reasoning about \emph{circular behavior} and \emph{lock-step execution}
(for ease of verification and simplicity of invariants).
We draw our inspiration from the literature on language-independent verification of partial correctness
(\cite{RosuS12oopsla,RosuSCM13lics,StefanescuCMMSR19})
and program equivalence (\cite{CiobacaLRR16,CiobacaLRR14}).
Again, we elaborate on the similarities and differences in \Cref{sec:discussion}. 

\section{Preliminaries}

\subsection{($\mu$-free) Matching Logic}

We work with a variant of matching logic described in
\cite{StefanescuCMMSR19,RosuSCM13lics}.

\begin{definition}[Matching logic syntax and semantics]\label{def:matchinglogic}
We define the matching logic syntax and semantics as follows.
\begin{enumerate}
    \item A matching logic \emph{signature} $\mathbf{\Sigma} = (\Sigma, \mathit{Var})$ is a many-sorted algebraic signature $\Sigma$ together with a sort-wise infinite set of variables $\mathit{Var}$.
    \item Let $T_{\Sigma}(\mathit{Var})$ denote the free $\Sigma$-algebra of terms with variables 
          in $\mathit{Var}$.
          Let $T_{\Sigma, s}(\mathit{Var})$ denote the set of $\Sigma$-terms (with variables in $\mathit{Var})$ of sort $s$.
    \item Let $\mathcal{T}$ be a $\Sigma$-algebra, and $f$ be a symbol from $\Sigma$.
          We use the notation $\mathcal{T}_f$ to denote the interpretation of $f$ in $\mathcal{T}$.
    \item A function $\rho : \mathit{Var} \to \mathcal{T}$, where $\mathcal{T}$ is a $\Sigma$-algebra,
          extends uniquely (in the usual way) to a $\Sigma$-algebra morphism
          $\rho : T_{\Sigma}(\mathit{Var}) \to \mathcal{T}$.
    \item The set of \emph{nullary predicate symbols} $P_\epsilon((\Sigma, \mathit{Var}))$
          (or just $P_\epsilon$ if $(\Sigma, \mathit{Var})$ is known from the context) is
          defined to contain exactly terms $\phi \in T_{\Sigma, s}(\mathit{Var})$.
    \item A matching logic $(\Sigma, \mathit{Var})$-formula (aka $(\Sigma, \mathit{Var})$-\emph{pattern})
          of sort $s$
          is a $(\Sigma, P_\epsilon)-\FOLeq$ formula (that is, a $\FOLeq$ formula where function symbols are
          exactly symbols from $\Sigma$, and where nullary predicate symbols are exactly
          terms $\phi \in T_{\Sigma, s}(\mathit{Var})$, without any $k$-ary predicate symbols for $k > 0$).
          We let $\Pattern(\mathbf{\Sigma})$ (or just $\Pattern$ when $\mathbf{\Sigma}$ is known from the context)
          denote the set of all $\mathbf{\Sigma}$-patterns.
    \item Let $\mathit{FV}(\varphi)$ denote the set of all free variables of $\varphi$.
    \item A matching logic pattern is \emph{structureless} if it contains
          no terms $\phi \in T_{\Sigma, s}(\mathit{Var})$ used as predicates.
    \item A \emph{constrained term} is a pattern of the form $\phi \land P$,
          where $\phi \in T_{\Sigma, s}(\mathit{Var})$ and $P$ a structureless pattern.
    \item A matching logic $\Sigma$-\emph{model} $\mathcal{T}$ is a $\Sigma$-algebra with non-empty carrier sets.
    \item A matching logic \emph{semantics} is given by means of
          the satisfaction relation $\vDash_{\ML}$ between a matching logic $\Sigma$-model,
          a model element, and a valuation,
          defined inductively as
          \begin{itemize}
              \item $(\mathcal{T}, \gamma, \rho) \vDash \phi$ iff $\gamma = \rho(\pi)$, where $\phi \in T_{\Sigma, s}(\mathit{Var})$;
              \item $(\mathcal{T}, \gamma, \rho) \vDash \varphi_1 \land \varphi_2$ iff
                $(\mathcal{T}, \gamma, \rho) \vDash \varphi_1$ and
                $(\mathcal{T}, \gamma, \rho) \vDash \varphi_2$;
              \item $(\mathcal{T}, \gamma, \rho) \vDash \neg \varphi$ iff
                $(\mathcal{T}, \gamma, \rho) \not\vDash \varphi$;
              \item $(\mathcal{T}, \gamma, \rho) \vDash \exists x : s.\, \varphi$ iff
                $(\mathcal{T}, \gamma, \rho^\prime) \vDash \varphi$ for some $\rho^\prime$ such that
                $\rho^\prime(y) = \rho(y)$ for all $y \in \mathit{Var} \setminus \{ x \}$
                and $\rho^\prime(x) \in \mathcal{T}_s$;
          \end{itemize}
          
\end{enumerate}

\end{definition}

Validity of a structureless pattern does not depend on the selected model element.
\begin{lemma}\label{lem:structurelessSemantics}
Let $\mathcal{T}$ be a matching logic $\Sigma$-model, $\gamma,\gamma^\prime \in \mathcal{T}$ model elements,
and $\rho$ a $\mathcal{T}$-valuation. Then for any structureless pattern $P$,
\begin{equation*}
    (\mathcal{T}, \gamma, \rho) \vDash P \iff (\mathcal{T}, \gamma^\prime, \rho) \vDash P \, .
\end{equation*}
Therefore, when $P$ is structureless, we may sometimes write $(\mathcal{T}, \rho) \vDash P$ to mean that 
$(\mathcal{T}, \gamma, \rho) \vDash P$ for \emph{some} $\gamma \in \mathcal{T}$.
\end{lemma}

Also, validity of any pattern does not depend on those variables which the pattern does not mention.
\begin{lemma}\label{lem:unusedVariables}
    Let $\mathcal{T}$ be a matching logic model, $\gamma$ an element of this model,
    and $\varphi$ a pattern.
    Then for any two $\mathcal{T}$-valuations $\rho,\rho^\prime$
    satisfying $\rho^\prime(y) = \rho(y)$ for any $y \in \mathit{FV}(\varphi)$,
    \begin{equation*}
        (\mathcal{T}, \gamma, \rho) \vDash \varphi \iff (\mathcal{T}, \gamma, \rho^\prime) \vDash \varphi \, .
    \end{equation*}
\end{lemma}
\begin{proof}
Admitted.
\end{proof}


\subsection{One-path Reachability Logic}



\begin{definition}[\cite{StefanescuCMMSR19,RosuS12oopsla}]\label{def:basics}
We define reachability-logic signatures, rules, and systems as follows.
\begin{enumerate}
    \item A reachability-logic \emph{signature} is a pair $(\mathbf{\Sigma}, \mathit{Cfg})$,
          where $\mathbf{\Sigma}$ is a matching logic signature and $\mathit{Cfg}$ is a sort from $\mathbf{\Sigma}$.
          
    \item A \emph{one-path reachability rule} over reachability logic signature $(\mathbf{\Sigma}, \mathit{Cfg})$        is a pair $\varphi \Rightarrow^\exists \varphi^\prime$,
          where $\varphi$ and $\varphi^\prime$
          are $\mathbf{\Sigma}$-patterns (which can have free variables) of sort $\mathit{Cfg}$.
          
    \item A \emph{reachability system} over a reachability-logic signature $((\Sigma, \mathit{Var}), \mathit{Cfg})$
          is a pair $\mathcal{S} = (\mathcal{T}, S)$, where $\mathcal{T}$ is a $\Sigma$-algebra
          and $S$ is a set of reachability rules over $((\Sigma, \mathit{Var}), \mathit{Cfg})$.
          
    \item A rule $\varphi \Rightarrow^\exists \varphi^\prime$ over $((\Sigma, \mathit{Var}), \mathit{Cfg})$
          is \emph{weakly well-defined}
          with respect to $\Sigma$-algebra $\mathcal{T}$
          iff
          for any $\gamma \in \Tcfg$ and $\rho : \Var \to \mathcal{T}$
          with $(\gamma, \rho) \vDash \varphi$,
          there exists $\gamma^\prime \in \Tcfg$ with $(\gamma^\prime , \rho) \vDash \varphi^\prime$.
          
    \item A reachability system $\mathcal{S}$ is \emph{weakly well-defined} iff each its rule is weakly     
          well-defined.
          
    \item A reachability system $\mathcal{S} = (\mathcal{T}, S)$ over $((\Sigma, \mathit{Var}), \mathit{Cfg})$ induces
          a \emph{transition system} \\
          $(\Tcfg , \Rightarrow_{\mathcal{S}})$,
          where $\gamma \Rightarrow_{\mathcal{S}} \gamma^\prime$
          for $\gamma, \gamma^\prime \in \Tcfg$
          iff there is some rule \\ $\varphi \Rightarrow^\exists \varphi^\prime \in S$
          and some valuation $\rho : \Var \to \mathcal{T}$ with $(\gamma, \rho) \vDash \varphi$
          and $(\gamma^\prime , \rho) \vDash \varphi^\prime$.

    \item A reachability system $(\mathcal{T}, S)$ is \emph{deterministic} iff the induced transition system
          is deterministic.
          
    \item A reachability system $(\mathcal{T}, S)$ is \emph{$\epsilon$-free}
          iff for any two configurations $\sigma, \sigma^\prime \in \mathcal{T}_{\mathit{Cfg}}$, if
          $\sigma \Rightarrow_{\mathcal{S}} \sigma^\prime$, then $\sigma \not = \sigma^\prime$.

    \item A configuration $\gamma \in \Tcfg$ \emph{terminates} in $(\Tcfg , \Rightarrow_{\mathcal{S}})$
          iff there is no infinite $\Rightarrow_{\mathcal{S}})$-sequence starting with $\gamma$.
          
    \item A \emph{$\Rightarrow_{\mathcal{S}}$-path} is a finite
          sequence $\gamma_0 \Rightarrow_{\mathcal{S}} \gamma_1 \Rightarrow_{\mathcal{S}} \ldots
          \Rightarrow_{\mathcal{S}} \gamma_n$
          with $\gamma_0,\ldots,\gamma_n \in \Tcfg$.
          
    \item A $\Rightarrow_{\mathcal{S}}$-path is \emph{complete}
          iff it is not a strict prefix of any
          other $\Rightarrow_{\mathcal{S}}$-path.

    \item \label{def:oprlSemantics}
          A one-path reachability rule $\varphi \Rightarrow^\exists \varphi^\prime$ is \emph{satisfied}
          in a reachability system $\mathcal{S} = (\mathcal{T}, S)$,
          written $\mathcal{S} \vDash_\RL \varphi \Rightarrow^\exists \varphi^\prime$,
          iff for every $\gamma \in \Tcfg$
          such that $\gamma$ terminates in $(\Tcfg, \Rightarrow_{\mathcal{S}})$
          and for any valuation $\rho : \Var \to \mathcal{T}$
          such that $(\gamma, \rho) \vDash \varphi$,
          there exists some $\gamma^\prime \in \Tcfg$
          such that
          $\gamma \Rightarrow^{*}_{\mathcal{S}} \gamma^\prime$
          and $(\gamma^\prime, \rho) \vDash \varphi^\prime$.
          
          
%    \item An \emph{all-path reachability rule} is a pair
%        $\varphi \Rightarrow^\forall \varphi^\prime$ of patterns $\varphi$ and $\varphi^\prime$.
%    
%    \item \label{def:aprlSemantics}
%          An all-path reachability rule $\varphi \Rightarrow^\forall \varphi^\prime$ is \emph{satisfied},
%          written $\mathcal{S} \vDash_\RL \varphi \Rightarrow^\forall \varphi^\prime$,
%          iff for all complete $\Rightarrow_{\mathcal{S}}$-paths $\tau$
%          starting with $\gamma \in \Tcfg$ and for all $\rho : \Var \to \mathcal{T}$
%          such that $(\gamma, \rho) \vDash \varphi$,
%          there exists some $\gamma^\prime \in \tau$
%          such that $(\gamma^\prime, \rho) \vDash \varphi^\prime$.
\end{enumerate}

%\begin{figure}
%    \centering
%    \includegraphics[width=0.5\textwidth]{img/onepath-rl.png}
%    \caption{One-path reachability-logic proof system.
%    The use of $\Rightarrow^+$ in sequent means that it was derived without Reflexivity.
%    TODO retypeset}
%    \label{fig:RLproofsystem}
%\end{figure}

We have RL sequents of the shape
$\mathcal{T}, A, C \vdash_\RL \varphi \Rightarrow^\exists \varphi^\prime$.

\end{definition}

\begin{remark}\label{rem:shapeOfReachabilityRules}
For simplicity, we restrict the class of reachability systems we work with to those whose reachability rules
have the shape
\begin{equation*}
    \bigvee_{i=1}^{m} (\phi_i \land P_i) \Rightarrow^\exists \exists \vec{Y}.\, \bigvee_{j=1}^{n} (\phi^\prime_j \land P^\prime_j) \, .
\end{equation*}
\end{remark}

\begin{remark}\label{rem:noEmptySteps}
We work only with $\epsilon$-free reachability systems.
\end{remark}

\section{Cartesian Reachability Logic}
Cartesian reachability logic is an extension of (one-path) reachability logic.

\begin{definition}[One-Path Cartesian Reachability Rule]\label{def:opCRLsemantics}
    We define syntax and semantics of cartesian reachability rules as follows.
\begin{itemize}
    \item 
        A One-Path Cartesian reachability rule of arity $k$ has the shape
        \begin{equation*}
        (\varphi_1,\ldots,\varphi_k) \land \varphi \Rightarrow^{c\exists} \exists \vec{Y}.\, (\psi_1,\ldots,\psi_k) \land \psi \, ,
        \end{equation*}
        where $\varphi, \psi$ are structureless patterns and $\varphi_j, \psi_j$ for any $j \in \{ 1, \ldots, k \}$ are
        existentially quantified\jt{Check whether we need that.} disjunctions of constrained terms.
    \item 
    A One-Path Cartesian reachability rule
    \begin{equation*}
     (\varphi_1,\ldots,\varphi_k) \land \varphi
     \Rightarrow^{c\exists} \exists \vec{Y}.\, (\psi_1,\ldots,\psi_k) \land \psi   
    \end{equation*}
    is \emph{valid} in a reachability system $\mathcal{S} = (\mathcal{T}, S)$,
    written
    \begin{equation*}
        \mathcal{S} \vDash_\CRL (\varphi_1,\ldots,\varphi_k) \land \varphi
     \Rightarrow^{c\exists} \exists \vec{Y}.\, (\psi_1,\ldots,\psi_k) \land \psi \, ,
    \end{equation*}
    iff for all configurations $\gamma_1,\ldots,\gamma_k \in \Tcfg$
    which terminate in $(\Tcfg, \Rightarrow_{\mathcal{S}})$
    and any two $\mathcal{T}$-valuations $\rho,\rho^\prime$
    satisfying $\rho(v) = \rho^\prime(v)$ for any $v \in \mathit{Var} \setminus \vec{Y}$,
    whenever $(\gamma_1,\rho) \vDash \varphi_1 \land \varphi$ and \ldots
    and $(\gamma_k,\rho) \vDash \varphi_k \land \varphi$,
    then there exist configurations $\gamma_1^\prime,\ldots,\gamma_k^\prime \in \Tcfg$
    such that $\gamma_1 \Rightarrow^{*}_{\mathcal{S}} \gamma_1^\prime$  
    and \ldots and $\gamma_k \Rightarrow^{*}_{\mathcal{S}} \gamma_k^\prime$,
    and
    $(\gamma_1^\prime,\rho^\prime) \vDash \psi_1 \land \psi$ and \ldots and $(\gamma_k^\prime, \rho^\prime) \vDash \psi_k \land \psi$.
\end{itemize}
\end{definition}

% TODO remark that this is not the same as k "normal" reachability rules.
% An example (monotonicity from the file)

\begin{remark}
\Cref{def:opCRLsemantics} extends \Cref{def:oprlSemantics} of \Cref{def:basics}:
if we fix $k=1$, then
\begin{align*}
    (\mathcal{T}, S) \vDash_\CRL
    (\varphi_1) \land \top  \Rightarrow^{c\exists}
    (\psi_1) \land \top
    \iff
    (\mathcal{T}, S) \vDash_\RL \varphi_1 \Rightarrow^{\exists} \psi_1 \, .
\end{align*}
\end{remark}

%\begin{definition}[All-Path Cartesian Reachability Rule]\label{def:apCRLsemantics}
%An all-path Cartesian reachability rule
%$(\varphi_1,\ldots,\varphi_k) \land \varphi \Rightarrow^{c\forall} (\psi_1,\ldots,\psi_k) \land \psi$
%of arity $k$
%is \emph{valid} in a reachability system $\mathcal{S} = (\mathcal{T}, S)$,
%written
%$\mathcal{S} \vDash_\CRL (\varphi_1,\ldots,\varphi_k) \land \varphi \Rightarrow^{c\forall}
%(\psi_1,\ldots,\psi_k) \land \psi$,
%iff for all configurations $\sigma_1,\ldots,\sigma_k \in \Tcfg$ \traian{Why $\sigma$ instead of $\gamma$?}
%and any $\mathcal{T}$-valuation $\rho$,
%whenever $(\sigma_1, \rho) \vDash \varphi_1 \land \varphi$ and \ldots
%and $(\sigma_k, \rho) \vDash \varphi_k \land \varphi$,
%then for every $k$-tuple of complete paths $(\pi_1, \ldots, \pi_k)$
%such that
%$\sigma_1 = \pi_1(0) \land \ldots \land \sigma_k = \pi_k(0)$,
%there exist indices $i_1, \ldots, i_k$ such that
%$(\pi_1(i_1), \rho) \vDash \varphi_1 \land \psi$ and \ldots and $(\pi_k(i_k), \rho) \vDash \varphi_k \land \psi$.
%\end{definition}

\begin{definition}\label{def:starextension}
We translate a language semantics into a semantics for lists of configurations as follows.
\begin{enumerate}
    \item Let $((\Sigma, \mathit{Var}), \mathit{Cfg})$ be a reachability-logic signature.
          Then $((\Sigma, \mathit{Var}^*), \mathit{Cfg})^*$ = $((\Sigma^*, \mathit{Var}^*), \mathit{Cfg}^*)$,
          where
          \begin{enumerate}
              \item $\Sigma^* = \Sigma \cup \{ \mathit{cfgitem}, \mathit{cfgconcat}, \mathit{cfgheat}, \mathit{cfgnil} \}$
              \item $\mathit{Cfg}^*$ is a fresh sort (representing the sort of lists of configurations);
              \item $\mathit{Var}^* = \mathit{Var} \cup \mathit{Var}_{\mathit{Cfg}^*}$,
              where $\mathit{Var}_{\mathit{Cfg}^*}$ is an infinite set of variables of sort $\mathit{Cfg}^*$,
              distinct from varibles in $\mathit{Var}$;
              \item $\mathit{cfgitem}$ a fresh symbol of sort $\mathit{Cfg} \to \mathit{Cfg}^*$;
              \item $\mathit{cfgnil}$ a fresh symbol of sort $\mathit{Cfg}^*$;
              \item $\mathit{cfgconcat}$ a fresh symbol of sort $\mathit{Cfg}^* \times \mathit{Cfg}^* \to \mathit{Cfg}^*$; and
              \item $\mathit{cfgheat}$ is a fresh symbol of sort $\mathit{Cfg}^* \times \mathit{Cfg} \times \mathit{Cfg}^* \to \mathit{Cfg}^*$.
          \end{enumerate}
    \item Let $S$ be a set of reachability rules over $(\mathbf{\Sigma}, \mathit{Cfg})$.
          We generate a set of reachability rules $S^*$ over $(\mathbf{\Sigma}, \mathit{Cfg})^*$
          by
          \begin{enumerate}
              \item defining a function $\mathit{heat} : \mathit{Var} \times \Pattern \times \mathit{Var} \to \Pattern$ by
              \begin{align*}
                  \mathit{heat}(L, \exists \vec{X}.\, \bigvee_{i=1}^{m} (\phi_i \land P_i), R)
                  = \exists \vec{X}.\, \bigvee_{i=1}^{m} ( \mathit{cfgheat(L, \phi_i, R)} \land P_i)
              \end{align*}
              \item setting
              \begin{align*}
              S^* = \{ \mathit{heat}(L, \varphi, R) \Rightarrow^\exists \mathit{heat}(L, \varphi^\prime, R)
              \mid  ( \varphi \Rightarrow^\exists \varphi^\prime ) \in S \} \, ,
            \end{align*}
                          where $L,R$ are distinct fresh variables (not occurring in any rule in $S$).
          \end{enumerate}
    \item Let $(\Sigma, \mathit{Var})$ be a matching logic signature, and let $\mathcal{T}$ be a configuration model; that is, a $\Sigma$-algebra.
          We generate a $\Sigma^*$-algebra $\mathcal{T}*$, which interprets all sorts and symbols from
          $\Sigma$ as in $\mathcal{T}$, and in addition interprets
          \begin{enumerate}
              \item the sort $\mathit{Cfg}*$ as the set of all finite lists
              $[c_1;\ldots;c_n]$ for $n \in \mathbb{N}$, where $c_i$ is an element of sort $\mathit{Cfg}$
              for any $0 \leq i \leq n$;
              \item the symbol $\mathit{cfgitem}$ as the function $\lambda c.\, [c]$;
              \item the symbol $\mathit{cfgnil}$ as the empty list ($[]$);
              \item the symbol $\mathit{cfgconcat}$ as the function $\lambda l_1,l_2.\, l_1 \texttt{++} l_2$,
                where $\texttt{++}$ is list concatenation; and
              \item the symbol $\mathit{cfgheat}$ as the function
                $\lambda l_1, c, l_2.\, l_1 \texttt{++} [c] \texttt{++} l_2$.
          \end{enumerate}

    \item Let $(\Sigma, \mathit{Var})$ be a matching logic signature, let $\mathcal{T}$ be a configuration model,
        and let $\rho$ be a $\mathcal{T}$-valuation.
        We define a $\mathcal{T}^*$-valuation $\rho^*$ by letting $\rho^*(v) = \rho(v)$ for any $v \in \mathit{Var}$,
        and letting $\rho^*(v) = a$, where $a$ is some arbitrary element of sort $\mathit{Cfg}^*$, for
        any variable $v$ of sort $\mathit{Cfg}^*$.
          
    \item Let $\mathcal{S} = (\mathcal{T}, S)$ be a reachability system over $(\Sigma, \mathit{Cfg})$.
          We generate a reachability system $\mathcal{S}^*$ over $(\Sigma, \mathit{Cfg})^*$
          by setting $\mathcal{S}^* = (\mathcal{T}^*, S^*)$.
\end{enumerate}
\end{definition}

\begin{lemma}\label{lem:rhoStarOfPi}
    Let $(\Sigma, \mathit{Var})$ be a matching logic signature, $\mathcal{T}$ be a configuration model,
    and $\rho$ be a $\mathcal{T}$-valuation. Then for any basic $(\Sigma, \mathit{Var})$-pattern $\pi$,
    \begin{equation}
        \rho^*(\pi) = \rho(\pi) \, .
    \end{equation}
\end{lemma}

\begin{lemma}\label{lem:starConservative}
    The star extension on matching logic models is conservative, in the following sense.
    For any $\Sigma$-model $\mathcal{T}$, any $\mathcal{T}$-valuation $\rho$,
    any $\Sigma$-sort $s$,
    any $\gamma \in \mathcal{T}_s$,
    and any matching logic $s$-pattern $\varphi$,
    \begin{equation*}
        (\mathcal{T}, \gamma, \rho) \vDash \varphi \iff (\mathcal{T}^*, \gamma, \rho^*) \vDash \varphi
    \end{equation*}
\end{lemma}

\begin{lemma}\label{lem:compositeStep}
    Let $\mathcal{S} = (\mathcal{T}, S)$ be a reachability system over $(\Sigma, \mathit{Cfg})$.
    For any $k \geq 1$, any configurations $c_1,\ldots,c_k, c^\prime \in \Tcfg$, and any $1 \leq i \leq k$,
    we have
    \begin{equation*}
        c_i \Rightarrow_{\mathcal{S}} c^\prime
                    \iff
        [c_1,\ldots,c_k] \Rightarrow_{\mathcal{S}^*} [c_1, \ldots, c_{i-1}, c^\prime, c_{i+1}, \ldots, c_k]
    \end{equation*}
\end{lemma}


\begin{definition}\label{def:mkList}
We define $\mathit{mkList}$ by letting
\begin{itemize}
    \item $\mathit{mkList}(\phi) = \mathit{cfgitem}(\phi)$; and
    \item $\mathit{mkList}(\phi_1, \ldots, \phi_k) = \mathit{cfgconcat}(\mathit{cfgitem}(\phi), \mathit{mkList}(\phi_2, \ldots, \phi_k))$ whenever $k > 1$.
\end{itemize}
\end{definition}

\begin{definition}\label{def:flatten}
    We let
    \begin{equation*}
        \mathit{flatten}(\exists \vec{X}.\, (\phi_1 \land P_1,\ldots,\phi_k \land P_k) \land P)
        \equiv \exists \vec{X}.\, \mathit{mkList}(\phi_1,\ldots,\phi_k) \land P \land P_1 \land \ldots \land P_k \, ,
    \end{equation*}
    and
    \begin{equation*}
        \mathit{flatten}^\exists(\Psi,\Psi^\prime) \equiv \mathit{flatten}(\Psi) \Rightarrow^\exists \mathit{flatten}(\Psi^\prime) \, .
    \end{equation*}
\end{definition}

\begin{theorem}\label{thm:correspondence}
\begin{equation*}
\mathcal{S} \vDash_{\CRL} \Psi \Rightarrow^{c\exists} \Psi^\prime \iff \mathcal{S}^* \vDash_\RL \mathit{flatten}^\exists(\Psi, \Psi^\prime)
\end{equation*}
\end{theorem}

\section{Proof System}

The proof system derives claims of the shape
$\mathcal{S}, \vdash_\CRL \Phi \Downarrow_{C,E} \Psi$,
where $\Phi$ is of the shape
$(\varphi_1, \ldots, \varphi_k) \land P$
and $\Psi$ is of the shape
$\exists \vec{Y}.\, (\varphi^\prime_1, \ldots, \varphi^\prime_k) \land P^\prime$,
where $P,P^\prime$ are structureless FOL formulas
and every $\varphi_i$ and $\varphi^\prime_i$ has the structure of
$\exists x_1,\ldots,x_n. (\phi_1 \land P_1) \lor \ldots (\phi_m \land P_m)$
and $\exists x^\prime_1,\ldots,x^\prime_{n^\prime}. (\phi^\prime_1 \land P^\prime_1) \lor \ldots (\phi^\prime_m \land P^\prime_m)$, respectively.
The idea is that $P$ is the part of the claim that relates variables from different components.
Initially, the proof starts with the claim
$\mathcal{S} \vdash_\CRL \Phi \Downarrow_{\emptyset, \emptyset} \Psi$.


\begin{figure}
    \centering
    \begin{align*}
    & \prftree[l]{Reflexivity}{\mathcal{S} \vdash_\CRL \Psi \Downarrow_{\emptyset,E} \Psi}
    \end{align*}
    \begin{align*}
    & \prftree[l]{Axiom}{\Psi \in E}{\mathcal{S} \vdash_\CRL \Psi \Downarrow_{C,E} \Psi^\prime}
    \end{align*}
    \begin{align*}
    & \prftree[l]{Reduce}
      {(\mathcal{T}^*, S^* \cup \mathit{flatten}^\exists(E, \Psi^\prime)), \emptyset \vdash_\RL
        \mathit{flatten}^\exists(\Psi, \Psi^\prime) }
      {(\mathcal{T}, S) \vdash_\CRL \Psi \Downarrow_{C,E} \Psi^\prime}
    \end{align*}
    \begin{align*}
    & \prftree[l]{Case}
    { \prfStackPremises
      {\mathcal{S} \vdash_\CRL (\varphi_1, \ldots, \varphi_{i-1}, \varphi_i, \varphi_{i+1}, \ldots, \varphi_k) \land P^\prime \Downarrow_{C, E} \Psi^\prime }
      {\mathcal{S} \vdash_\CRL (\varphi_1, \ldots, \varphi_{i-1}, \psi_i, \varphi_{i+1}, \ldots, \varphi_k) \land P^\prime \Downarrow_{C, E} \Psi^\prime }
    }
    {\mathcal{S} \vdash_\CRL (\varphi_1, \ldots, \varphi_{i-1}, (\varphi_i \lor \psi_i), \varphi_{i+1}, \ldots, \varphi_k) \land P^\prime \Downarrow_{C, E} \Psi^\prime}
    \end{align*}
    \begin{align*}
    & \prftree[l]{Step}
    { \prfStackPremises
       {\varphi \Rightarrow^\exists \varphi^\prime \in S}
       {\mathcal{T} \vDash_\ML \varphi_i \leftrightarrow \mathit{constrain}(P^\prime, \varphi)}
       {P^\prime \mbox{ is a structureless FOL formula}}
       {  (\mathcal{T}, S) \vdash_\CRL (\varphi_1, \ldots, \varphi_{i-1}, \mathit{constrain}(P^\prime, \varphi^\prime), \varphi_{i+1}, \ldots, \varphi_k)
          \land P
          \Downarrow_{\emptyset, (C \cup E)} \Psi^\prime
      }
    }
    {(\mathcal{T}, S) \vdash_\CRL (\varphi_1, \ldots, \varphi_{i-1}, \varphi_i, \varphi_{i+1}, \ldots, \varphi_k) \land P \Downarrow_{C, E} \Psi^\prime}
    \end{align*}
    \begin{align*}
    & \prftree[l]{Circularity}
      { \mathcal{S} \vdash_\CRL \Psi \Downarrow_{C \cup \{ \Psi \} , E} \Psi^\prime}
      { \mathcal{S} \vdash_\CRL \Psi \Downarrow_{C, E} \Psi^\prime}
    \end{align*}
    \begin{align*}
    & \prftree[l]{Conseq}
      { \prfStackPremises
        { (\mathcal{T}, S) \vdash_\CRL \Phi^\prime \Downarrow_{C, E} \Psi^\prime}
        { \mathcal{T}^* \vDash_\ML \mathit{flatten}(\Phi) \rightarrow \mathit{flatten}(\Phi^\prime) }
      }
      { (\mathcal{T}, S) \vdash_\CRL \Phi \Downarrow_{C, E} \Psi^\prime}
    \end{align*}
%    \begin{align*}
%    & \prftree[l]{Conseq2}
%      { \prfStackPremises
%        { (\mathcal{T}, S) \vdash_\CRL (\varphi_1, \ldots, \varphi_k) \land P \Downarrow_{C, E} \Psi^\prime}
%        { \mathcal{T} \vDash_\ML \varphi_i \leftrightarrow \psi_i }
%      }
%      { (\mathcal{T}, S) \vdash_\CRL (\varphi_1^\prime, \ldots, \varphi_{i-1}, \varphi_{i}, \varphi_{i+1}, \ldots, \varphi_k^\prime) \land P^\prime \Downarrow_{C, E} \Psi^\prime}
%    \end{align*}

    %\begin{align*}
    %& \prftree[l]{Abstract}
      %{ \prfStackPremises
        %{ X \not\in \mathit{FV}(\Psi^\prime, \varphi_1, \ldots, \varphi_{i-1}, \varphi_{i+1}, \ldots,\varphi_k)
        %}
        %{(\mathcal{T}, S) \vdash_\CRL (\varphi_1, \ldots, \varphi_{i-1}, \varphi_i, \varphi_{i+1}, \ldots, \varphi_k) \land P \Downarrow_{C, E} \Psi^\prime}
      %}
      %{(\mathcal{T}, S) \vdash_\CRL (\varphi_1, \ldots, \varphi_{i-1}, \exists X.\, \varphi_i, \varphi_{i+1}, \ldots, \varphi_k) \land P \Downarrow_{C, E} \Psi^\prime}
    %\end{align*}
    
    \begin{align*}
    & \prftree[l]{Abstract}
      { \prfStackPremises
        { X \not\in \mathit{FV}(\Psi^\prime)
        }
        {(\mathcal{T}, S) \vdash_\CRL \exists \vec{Y}.\, (\varphi_1, \ldots, \varphi_k) \land P \Downarrow_{C, E} \Psi^\prime}
      }
      {(\mathcal{T}, S) \vdash_\CRL \exists X, \vec{Y}.\, (\varphi_1, \ldots, \varphi_k) \land P \Downarrow_{C, E} \Psi^\prime}
    \end{align*}
    \caption{Proof System}
    \label{fig:my_label}
\end{figure}



\begin{lemma}\label{lem:CRLalmostSoundness}
    \begin{align*}
        & (\mathcal{T}, S) \vdash_\CRL \Psi \Downarrow_{C,E} \Psi^\prime \implies \\
        &
        (\mathcal{T}^*, S^* \cup \mathit{flatten}^\exists(E, \Psi^\prime)), \mathit{flatten}^\exists(C, \Psi^\prime) \vdash_\RL
          \mathit{flatten}^\exists(\Psi, \Psi^\prime) 
    \end{align*}
\end{lemma}

\begin{theorem}[Proof system soundness]\label{thm:proofsystemSoundness}
\begin{equation*}
    \mathcal{S} \vdash_\CRL \Psi \Downarrow_{\emptyset,\emptyset} \Psi^\prime \implies
    \mathcal{S} \vDash_{\CRL} \Psi \Rightarrow^{c\exists} \Psi^\prime
\end{equation*}
\end{theorem}
\begin{proof}[Proof of \Cref{thm:proofsystemSoundness}]
Assume $\mathcal{S} \vdash_\CRL \Psi \Downarrow_{\emptyset,\emptyset} \Psi^\prime$.
By \Cref{lem:CRLalmostSoundness}, we have $\mathcal{S} \vdash_\RL \mathit{flatten}^\exists(\Psi, \Psi^\prime)$.
By soundness of reachability logic, we have $\mathcal{S} \vDash_\RL \mathit{flatten}^\exists(\Psi, \Psi^\prime)$.
By \Cref{thm:correspondence}, 
we have $\mathcal{S} \vDash_{\CRL} \Psi \Rightarrow^{c\exists} \Psi^\prime$ and we are done.
\end{proof}

\section{Implementation}

\section{Discussion}\label{sec:discussion}

\subsection{Relation to Cartesian Hoare logic}

\subsubsection{(Non)determinism}
We base our work on the \emph{one-path} variant of reachability logic.
Consequently, CRL inherits a known limitation of one-path reachability logic: that the tight correspondence between
one-path RL and Hoare logics is limited to deterministic languages.
However, we would still want to prove the following theorem.
\begin{theorem}
CRL extends CHL on the deterministic fragment of the CHL-supported language.
That is, given any program $P$ in the deterministic fragment of the CHL's imperative language,
a sound reachability-logic formalization (that is, a reachability system) $\mathcal{S}_{\mathit{IMP}}$ of the CHL's imperative language,
and firstorder formulas $\Phi, \Psi$ over variables $\vec{x}_1,\ldots,\vec{x}_k$,
\begin{equation*}
    \vDash_{\mathit{CHL}} ||\Phi||\ P\ ||\Psi||
    \iff
    \mathcal{S}_{\mathit{IMP}} \vDash_\CRL \mathit{tr}(P, \Phi) \Rightarrow^{c\exists} \mathit{tr}(P, \Psi) \, .
\end{equation*}
\end{theorem}
\begin{proof}
Admitted. Use the relationship between one-path CRL and all-path CRL on deterministic languages (TODO).
\end{proof}

\subsubsection{Main Idea and Proof Technique}

Our understanding of the inner workings of CHL is based on the extended, unpublished version (\cite{SousaD16Extended})
of \cite{SousaD16}.
There, the authors define a \emph{linearization operation} on lists of programs, which roughly corresponds to our
\emph{star extension} of the language's semantics.
Then, the authors prove lemmas saying that a CHL triple with a list of programs inside is derivable
in the CHL proof system
if and only if 
a Hoare triple having the same list of programs, but linearized, inside, is derivable;
the "only if" implication corresponds to our \Cref{lem:CRLalmostSoundness}, where we construct
an RL proof from a CRL proof,
while the "if" implication corresponds to our Reduce rule.
Furthermore, in the proof of soundness of CHL, the authors assume soundness of the self-composition technique;
self-composition corresponds to our \emph{star extension} and its soundness to our \Cref{thm:correspondence}.
Finally \cite{SousaD16Extended} assumes soundness and relative completeness of the underling Hoare logic;
similarly, we assume soundness and relative completeness of reachability logic.
However, for completeness, we have to prove that \emph{star extension} preserves decidability.

\subsubsection{Differences}
There are also differences between the CHL and CRL techniques.
First, our proof system has only 8 rules, and they do not mention any programming language construct,
while CHL has 17 rules (not counting the Expand rule), half of which are specific to the underlying language.

Second, there is a redundancy between the language-specific CHL rules and the Hoare logic rules of the
programming language: for example, conditional statement ("if") has (1) a rule in the formal semantics of the language,
(2) a rule in the Hoare logic (not shown in the paper), and (3) a rule in CHL.
When considering that the three rules have to play nice together (that is, CHL and Hoare logic rules have to be sound with respect to the semantics), someone had to think about the conditional statement at least five times .
We consider this to be highly uneconomical
- and the situation
is even worse for the looping construct ("while-with-breaks"), which is supported using additional CHL rules.
In contrast, in the CRL/RL framework, it is enough to design each language construct once - when giving
semantics to it.


Third, in CHL the support for lock-step reasoning is hard-wired into the rules for loops,
while in our framework, lock-step reasoning is not limited to loops, but can support arbitrary sources
of circular behavior - including loops, recursion, gotos.
Therefore, while we are inspired by the \emph{idea} of lock-step execution from \cite{SousaD16},
for the \emph{realization} of this idea we turn to the literature on \emph{equivalence checking}.

\subsection{Relation to semantic-based program equivalence}

TODO

\subsection{Other Related Work}


Also, a game-based technique for verifying software hyperproperties beyond $k$-safety
has been developed in \cite{BeutnerF22}.
This technique works with \emph{symbolic transition systems},
so it already is language-independent \emph{in some sense}. However, it is not clear how to use the technique
with an arbitrary language $L$, without writing a compiler from $L$ to symbolic transition systems first.



\bibliography{bibliography}
\bibliographystyle{plain}

\appendix

\section{Proofs}
\input{proofs}

\end{document}
