\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amssymb,mathtools}
\usepackage{amsthm}
\usepackage{thmtools}
\usepackage{hyperref}
% `cleveref` has to be loaded after `hyperref`
\usepackage{cleveref}
\usepackage{stackengine}
\usepackage{minted}
\usepackage{tcolorbox}
\usepackage{multicol}
\usepackage{prftree}
\usepackage{fancyvrb}
\usepackage{csquotes}
\usepackage{appendix}

\title{Cartesian Reachability Logic}
\author{Jan Tu≈°il }
\date{February 2022}

\declaretheorem[]{example}
\declaretheorem[]{definition}
\declaretheorem[]{lemma}
\declaretheorem[]{theorem}
\declaretheorem[]{remark}

\newcommand{\RL}{\mathsf{RL}}
\newcommand{\ML}{\mathsf{ML}}
\newcommand{\CRL}{\mathsf{CRL}}
\newcommand{\Var}{\mathit{Var}}
\newcommand{\Tcfg}{\mathcal{T}_{\mathit{Cfg}}}

\newcommand\oast{\stackMath\mathbin{\stackinset{c}{0ex}{c}{0ex}{\ast}{\bigcirc}}}

\begin{document}

\maketitle

\section{Introduction}

\section{Preliminaries}

\subsection{($\mu$-free) Matching Logic}

\subsection{One-path Reachability Logic}



\begin{definition}[\cite{StefanescuCMMSR19}]
We define reachability-logic signatures, rules, and systems as follows.
\begin{enumerate}
    \item A reachability-logic \emph{signature} is a pair $(\Sigma, \mathit{Cfg})$,
          where $\Sigma$ is a matching logic signature and $\mathit{Cfg}$ is a sort.
          
    \item A \emph{one-path reachability rule} over reachability logic signature $(\Sigma, \mathit{Cfg})$        is a pair $\varphi \Rightarrow^\exists \varphi^\prime$,
          where $\varphi$ and $\varphi^\prime$
          are patterns (which can have free variables) of sort $\mathit{Cfg}$.
          
    \item A \emph{reachability system} over a reachability-logic signature $(\Sigma, \mathit{Cfg})$
          is a pair $\mathcal{S} = (\mathcal{T}, S)$, where $\mathcal{T}$ is a $\Sigma$-algebra
          and $S$ is a set of reachability rules over $(\Sigma, \mathit{Cfg})$.
          
    \item A rule $\varphi \Rightarrow^\exists \varphi^\prime$ over $(\Sigma, \mathit{Cfg})$
          is \emph{weakly well-defined}
          with respect to $\Sigma$-algebra $\mathcal{T}$
          iff
          for any $\gamma \in \Tcfg$ and $\rho : \Var \to \mathcal{T}$
          with $(\gamma, \rho) \vDash \varphi$,
          there exists $\gamma^\prime \in \Tcfg$ with $(\gamma^\prime , \rho) \vDash \varphi^\prime$.
          
    \item A reachability system $\mathcal{S}$ is \emph{weakly well-defined} iff each its rule is weakly     
          well-defined.
          
    \item A reachability system $\mathcal{S} = (\mathcal{T}, S)$ over $(\Sigma, \mathit{Cfg})$ induces
          a \emph{transition system} \\
          $(\Tcfg , \Rightarrow_{\mathcal{S}})$,
          where $\gamma \Rightarrow_{\mathcal{S}} \gamma^\prime$
          for $\gamma, \gamma^\prime \in \Tcfg$
          iff there is some rule \\ $\varphi \Rightarrow^\exists \varphi^\prime \in S$
          and some valuation $\rho : \Var \to \mathcal{T}$ with $(\gamma, \rho) \vDash \varphi$
          and $(\gamma^\prime , \rho) \vDash \varphi^\prime$.

    \item A reachability system $(\mathcal{T}, S)$ is \emph{deterministic} iff the induced transition system
          is deterministic.

    \item A configuration $\gamma \in \Tcfg$ \emph{terminates} in $(\Tcfg , \Rightarrow_{\mathcal{S}})$
          iff there is no infinite $\Rightarrow_{\mathcal{S}})$-sequence starting with $\gamma$.
          
    \item A \emph{$\Rightarrow_{\mathcal{S}}$-path} is a finite
          sequence $\gamma_0 \Rightarrow_{\mathcal{S}} \gamma_1 \Rightarrow_{\mathcal{S}} \ldots
          \Rightarrow_{\mathcal{S}} \gamma_n$
          with $\gamma_0,\ldots,\gamma_n \in \Tcfg$.
          
    \item A $\Rightarrow_{\mathcal{S}}$-path is \emph{complete}
          iff it is not a strict prefix of any
          other $\Rightarrow_{\mathcal{S}}$-path.

    \item A \emph{one-path reachability rule}
          is a pair $\varphi \Rightarrow^\exists \varphi^\prime$ of patterns $\varphi$ and $\varphi^\prime$.

    \item A one-path reachability rule $\varphi \Rightarrow^\exists$ is \emph{satisfied}
          in a reachability system $\mathcal{S}$,
          written $\mathcal{S} \vDash_\RL \varphi \Rightarrow^\exists \varphi^\prime$,
          iff for every $\gamma \in \Tcfg$
          such that $\gamma$ terminates in $(\Tcfg, \Rightarrow_{\mathcal{S}})$
          and for any valuation $\rho : \Var \to \mathcal{T}$
          such that $(\gamma, \rho) \vDash \varphi$,
          there exists some $\gamma^\prime \in \Tcfg$
          such that
          and $(\gamma^\prime, \rho) \vDash \varphi^\prime$

%    \item An all-path reachability rule $\varphi \Rightarrow^\forall$ is \emph{satisfied},
%          written $\mathcal{S} \vDash_\RL \varphi \Rightarrow^\forall \varphi^\prime$,
%          iff for all complete $\Rightarrow_{\mathcal{S}}$-paths $\tau$
%          starting with $\gamma \in \Tcfg$ and for all $\rho : \Var \to \mathcal{T}$
%          such that $(\gamma, \rho) \vDash \varphi$,
%          there exists some $\gamma^\prime \in \tau$
%          such that $(\gamma^\prime, \rho) \vDash \varphi^\prime$.
\end{enumerate}

\begin{figure}
    \centering
    \includegraphics[width=0.5\textwidth]{img/onepath-rl.png}
    \caption{One-path reachability-logic proof system.
    The use of $\Rightarrow^+$ in sequent means that it was derived without Reflexivity.
    TODO retypeset}
    \label{fig:RLproofsystem}
\end{figure}

We have RL sequents of the shape $\mathcal{T}, A, C \vdash_\RL \varphi \Rightarrow^\exists \varphi^\prime$.

\end{definition}

\section{Cartesian Reachability Logic}

We need to make the definition such that it works with reachability logic for the composite semantics.
Here is one attempt:
\begin{definition}\label{def:CRLsemantics}
A Cartesian reachability rule
$(\varphi_1,\ldots,\varphi_k) \land \varphi \Rightarrow^{c\exists} (\psi_1,\ldots,\psi_k) \land \psi$
of arity $k$
is \emph{valid} in a reachability system $(\mathcal{T}, S)$,
written
$(\mathcal{T}, S) \vDash_\CRL (\varphi_1,\ldots,\varphi_k) \land \varphi \Rightarrow^{c\exists}
(\psi_1,\ldots,\psi_k) \land \psi$,
iff for all configurations $\sigma_1,\ldots,\sigma_k \in \Tcfg$ and any $\mathcal{T}$-valuation $\rho$,
whenever $\sigma_1 \in |\varphi_1 \land \varphi|_\rho \land \ldots \land \sigma_k \in |\varphi_l \land \varphi|_\rho$,
then for every $k$-tuple complete paths $(\pi_1, \ldots, \pi_k)$
of respective lengths $l_1, \ldots, l_k$
such that
$\sigma_1 = \pi_1(0) \land \ldots \land \sigma_k = \pi_k(0)$,
it holds that 
$\pi_1(l_1-1) \in |\varphi_1 \land \psi|_\rho \land \ldots \land \pi_k(l_k-1) \in |\varphi_k \land \psi|_\rho$.
\end{definition}

TODOs:
\begin{itemize}
    \item Validate this definition against examples from the CHL paper.
    \item Have a "running example" - some programming language, like IMP?
    \item Have an example how do we perform lockstep execution on ifs.
    \item Conservativeness argument for the additional rules?
\end{itemize}

\begin{definition}
We translate a language semantics into a semantics for lists of configurations as follows.
\begin{enumerate}
    \item Let $(\Sigma, \mathit{Cfg})$ be a reachability-logic signature.
          Then $(\Sigma, \mathit{Cfg})^*$ = $(\Sigma^*, \mathit{Cfg}^*)$,
          where
          \begin{enumerate}
              \item $\Sigma^* = \Sigma \cup \{ \mathit{cfgitem}, \mathit{cfgconcat},
          %\mathit{cfgdummy},
          \mathit{cfgheat} \}$
              \item $\mathit{Cfg}^*$ is a fresh sort (representing the sort of lists of configurations);
              %\item $\mathit{cfgdummy}$ is a fresh symbol of sort $\mathit{Cfg}$;
              \item $\mathit{cfgitem}$ a fresh symbol of sort $\mathit{Cfg} \to \mathit{Cfg}^*$;
              \item $\mathit{cfgnil}$ a fresh symbol of sort $\mathit{Cfg}^*$;
              \item $\mathit{cfgconcat}$ a fresh symbol of sort $\mathit{Cfg}^* \times \mathit{Cfg}^* \to \mathit{Cfg}^*$; and
              \item $\mathit{cfgheat}$ is a fresh symbol of sort $\mathit{Cfg}^* \times \mathit{Cfg} \times \mathit{Cfg}^* \to \mathit{Cfg}^*$.
          \end{enumerate}
    \item Let $S$ be a set of reachability rules over $(\Sigma, \mathit{Cfg})$.
          We generate a set of reachability rules $S^*$ over $(\Sigma, \mathit{Cfg})^*$
          by
          \begin{enumerate}
              \item defining a function $\mathit{heat}$ by
              \begin{align*}
                  \mathit{heat}(L, \exists \vec{X}.\, \bigvee_{i=1}^{m} (\phi_i \land P_i), R)
                  = \exists \vec{X}.\, \bigvee_{i=1}^{m} ( \mathit{cfgheat(L, \phi_i, R)} \land P_i)
              \end{align*}
              \item setting
              \begin{align*}
              S^* = \{ \mathit{heat}(L, \varphi, R) \Rightarrow^\exists \mathit{heat}(L, \varphi^\prime, R)
              \mid  ( \varphi \Rightarrow^\exists \varphi^\prime ) \in S \} \, ,
            \end{align*}
                          where $L,R$ are distinct fresh variables (not occurring in any rule in $S$).
          \end{enumerate}
    \item Let $\mathcal{T}$ be a configuration model; that is, a $\Sigma$-algebra.
          We generate a $\Sigma^*$-algebra $\mathcal{T}*$, which interprets all sorts and symbols from
          $\Sigma$ as in $\mathcal{T}$, and in addition interprets
          \begin{enumerate}
              \item the sort $\mathit{Cfg}*$ as the set of all finite lists
              $[c_1;\ldots;c_n]$ for $n \in \mathbb{N}$, where $c_i$ is an element of sort $\mathit{Cfg}$
              for any $0 \leq i \leq n$;
              \item the symbol $\mathit{cfgitem}$ as the function $\lambda c.\, [c]$;
              \item the symbol $\mathit{cfgnil}$ as the empty list ($[]$);
              \item the symbol $\mathit{cfgconcat}$ as the function $\lambda l_1,l_2.\, l_1 \texttt{++} l_2$,
                where $\texttt{++}$ is list concatenation; and
              \item the symbol $\mathit{cfgheat}$ as the function
                $\lambda l_1, c, l_2.\, l_1 \texttt{++} [c] \texttt{++} l_2$.
          \end{enumerate}
          
    \item Let $\mathcal{S} = (\mathcal{T}, S)$ be a reachability system over $(\Sigma, \mathit{Cfg})$.
          We generate a reachability system $\mathcal{S}^*$ over $(\Sigma, \mathit{Cfg})^*$
          by setting $\mathcal{S}^* = (\mathcal{T}^*, S^*)$.
\end{enumerate}
\end{definition}

\begin{lemma}
    The star extension on matching logic models is conservative.
\end{lemma}
\begin{proof}
Admitted.
\end{proof}

\begin{lemma}
    Let $\mathcal{S} = (\mathcal{T}, S)$ be a reachability-logic system over $(\Sigma, \mathit{Cfg})$.
    For any $k \geq 1$, any configurations $c_1,\ldots,c_k, c^\prime \in \Tcfg$, and any $1 \leq i \leq k$,
    we have
    \begin{equation*}
        c_i \Rightarrow_{\mathcal{S}} c^\prime
                    \iff
        [c_1,\ldots,c_k] \Rightarrow_{\mathcal{S}^*} [c_1, \ldots, c_{i-1}, c^\prime, c_{i+1}, \ldots, c_k]
    \end{equation*}
\end{lemma}
\begin{proof}
Admitted.
\end{proof}


\section{Proof System}

The proof system derives claims of the shape
$\mathcal{S}, \vdash_\CRL (\varphi_1, \ldots, \varphi_k) \land P \Downarrow_{C,E} \Psi$,
where $P$ is a patternless FOL formula.
Also, every $\varphi_i$ has the structure of
$\exists x_1,\ldots,x_n. (\phi_1 \land P_1) \lor \ldots (\phi_m \land P_m)$.
The idea is that $P$ is the part of the claim that relates variables from different components.
Initially, the proof starts with the claim
$\mathcal{S} \vdash_\CRL (\varphi_1, \ldots, \varphi_k) \land P \Downarrow_{\emptyset, \emptyset} \Psi$.

\begin{definition}
We define $\mathit{mergePatterns}$ and $\mathit{flatten}$ as follows:
\begin{enumerate}
    \item
    \begin{align*}
     & \mathit{mergePatterns}(\exists \vec{X_1}.\, \bigvee_{i_{1}=1}^{m_1} (\phi_{i_1} \land P_{i_1}),
     \ldots, \exists \vec{X_n}.\, \bigvee_{i_{n}=1}^{m_n} (\phi_{i_n} \land P_{i_n}))
     \\ & = \exists \vec{X_1}\ldots\vec{X_n}.\, \bigvee_{i_{1}=1}^{m_1} \ldots \bigvee_{i_{n}=1}^{m_n}
       (\mathit{mkList}(\phi_{1, i_1}, \ldots, \phi_{n, i_n}) \land (P_{1, i_1} \land \ldots \land P_{n, i_n}))
    \end{align*}
    \item
        \begin{align*}
            & \mathit{constrain}(P, \exists x^\prime_1,\ldots,x^\prime_{n^\prime}.\, (\phi^\prime_1 \land P^\prime_1) \lor \ldots (\phi^\prime_m \land P^\prime_{m^\prime}))
            \\& = (\exists x^\prime_1,\ldots,x^\prime_{n^\prime}. (\phi^\prime_1 \land (P^\prime_1 \land P)) \lor \ldots (\phi^\prime_m \land (P^\prime_{m^\prime} \land P)))
    \end{align*}
    (we assume that $\alpha$-renaming of (free) variables of $P$ happens implicitly);
    \item
        \begin{align*}
            & \mathit{flatten}((\varphi_1, \ldots, \varphi_k) \land P)
            = \mathit{constrain}(P, \mathit{mergePatterns}(\varphi_1, \ldots, \varphi_k))
    \end{align*}
    \item $\mathit{flatten}^\exists(\Psi, \Psi^\prime) = \mathit{flatten}(\Psi) \Rightarrow^\exists \mathit{flatten}(\Psi^\prime)$
    \item $\mathit{flatten}^\exists(A, \Psi^\prime) = \{ \mathit{flatten}^\exists(\Psi, \Psi^\prime) \mid \Psi \in A \}$, where $A$ is a set.
\end{enumerate}
\end{definition}

\begin{lemma}\label{lem:constrain}
  For any structureless pattens $P, Q, P_1, \ldots, P_m$
  and any basic patterns $\phi_1, \ldots, \phi_m$,
    \begin{align*}
        \vDash_\ML & \mathit{constrain}(P \lor Q, \exists x_1,\ldots,x_{n}.\, (\phi_1 \land P_1) \lor \ldots (\phi_m \land P_{m})) \leftrightarrow
        \\ & ( \mathit{constrain}(P, \exists x_1,\ldots,x_{n}.\, (\phi_1 \land P_1) \lor \ldots (\phi_m \land P_{m}))
        \\ & \ \mathit{constrain}(Q, \exists x_1,\ldots,x_{n}.\, (\phi_1 \land P_1) \lor \ldots (\phi_m \land P_{m})) ) \, .
    \end{align*}
\end{lemma}
\begin{proof}
Admitted.
\end{proof}

\begin{lemma}\label{lem:doubleconstrain}
    \begin{align*}
        \vDash_\ML & \mathit{constrain}(P , \mathit{constrain}(Q, \varphi))
        \leftrightarrow \mathit{constrain}(P \land Q, \varphi)
    \end{align*}
\end{lemma}
\begin{proof}
Admitted.
\end{proof}

\begin{lemma}\label{lem:constrainMergeComm}
    \begin{align*}
        \vDash_\ML & \mathit{mergePatterns}(\varphi_1, \ldots, \varphi_{i-1}, \mathit{constrain}(P, \varphi_i), \varphi_{i+1}, \ldots, \varphi_k) \\
        & \leftrightarrow \mathit{constrain}(P, \mathit{mergePatterns(\varphi_1, \ldots, \varphi_k)})
    \end{align*}
\end{lemma}

\begin{lemma}\label{lem:constrainAsConjunction}
    \begin{align*}
        \vDash_{\ML} & \mathit{constrain}(P, \varphi) \leftrightarrow \varphi \land P
    \end{align*}
\end{lemma}

\begin{figure}
    \centering
    \begin{align*}
    & \prftree[l]{Reflexivity}{\mathcal{S} \vdash_\CRL \Psi \Downarrow_{\emptyset,E} \Psi}
    \end{align*}
    \begin{align*}
    & \prftree[l]{Axiom}{\Psi \in E}{\mathcal{S} \vdash_\CRL \Psi \Downarrow_{C,E} \Psi^\prime}
    \end{align*}
    \begin{align*}
    & \prftree[l]{Reduce}
      {(\mathcal{T}^*, S^* \cup \mathit{flatten}^\exists(E, \Psi^\prime)), \emptyset \vdash_\RL
        \mathit{flatten}^\exists(\Psi, \Psi^\prime) }
      {(\mathcal{T}, S) \vdash_\CRL \Psi \Downarrow_{C,E} \Psi^\prime}
    \end{align*}
    \begin{align*}
    & \prftree[l]{Case}
    { \prfStackPremises
      {\mathcal{S} \vdash_\CRL (\varphi_1, \ldots, \varphi_{i-1}, \varphi_i, \varphi_{i+1}, \ldots, \varphi_k) \land P^\prime \Downarrow_{C, E} \Psi^\prime }
      {\mathcal{S} \vdash_\CRL (\varphi_1, \ldots, \varphi_{i-1}, \psi_i, \varphi_{i+1}, \ldots, \varphi_k) \land P^\prime \Downarrow_{C, E} \Psi^\prime }
    }
    {\mathcal{S} \vdash_\CRL (\varphi_1, \ldots, \varphi_{i-1}, (\varphi_i \lor \psi_i), \varphi_{i+1}, \ldots, \varphi_k) \land P^\prime \Downarrow_{C, E} \Psi^\prime}
    \end{align*}
    \begin{align*}
    & \prftree[l]{Step}
    { \prfStackPremises
       {\varphi \Rightarrow^\exists \varphi^\prime \in S}
       {\mathcal{T} \vDash_\ML \varphi_i \leftrightarrow \mathit{constrain}(P^\prime, \varphi)}
       {P^\prime \mbox{ is a patternless FOL formula}}
       {  (\mathcal{T}, S) \vdash_\CRL (\varphi_1, \ldots, \varphi_{i-1}, \mathit{constrain}(P^\prime, \varphi^\prime), \varphi_{i+1}, \ldots, \varphi_k)
          \land P
          \Downarrow_{\emptyset, (C \cup E)} \Psi^\prime
      }
    }
    {(\mathcal{T}, S) \vdash_\CRL (\varphi_1, \ldots, \varphi_{i-1}, \varphi_i, \varphi_{i+1}, \ldots, \varphi_k) \land P \Downarrow_{C, E} \Psi^\prime}
    \end{align*}
    \begin{align*}
    & \prftree[l]{Circularity}
      { \mathcal{S} \vdash_\CRL \Psi \Downarrow_{C \cup \{ \Psi \} , E} \Psi^\prime}
      { \mathcal{S} \vdash_\CRL \Psi \Downarrow_{C, E} \Psi^\prime}
    \end{align*}
    \begin{align*}
    & \prftree[l]{Conseq}
      { \prfStackPremises
        { (\mathcal{T}, S) \vdash_\CRL \Phi^\prime \Downarrow_{C, E} \Psi^\prime}
        { \mathcal{T}^* \vDash_\ML \mathit{flatten}(\Phi) \leftrightarrow \mathit{flatten}(\Phi^\prime) }
      }
      { (\mathcal{T}, S) \vdash_\CRL \Phi \Downarrow_{C, E} \Psi^\prime}
    \end{align*}
%    \begin{align*}
%    & \prftree[l]{Conseq2}
%      { \prfStackPremises
%        { (\mathcal{T}, S) \vdash_\CRL (\varphi_1, \ldots, \varphi_k) \land P \Downarrow_{C, E} \Psi^\prime}
%        { \mathcal{T} \vDash_\ML \varphi_i \leftrightarrow \psi_i }
%      }
%      { (\mathcal{T}, S) \vdash_\CRL (\varphi_1^\prime, \ldots, \varphi_{i-1}, \varphi_{i}, \varphi_{i+1}, \ldots, \varphi_k^\prime) \land P^\prime \Downarrow_{C, E} \Psi^\prime}
%    \end{align*}

    \begin{align*}
    & \prftree[l]{Abstract}
      { \prfStackPremises
        { X \not\in \mathit{FV}(\Psi^\prime, \varphi_1, \ldots, \varphi_{i-1}, \varphi_{i+1}, \ldots,\varphi_k)
        }
        {(\mathcal{T}, S) \vdash_\CRL (\varphi_1, \ldots, \varphi_{i-1}, \varphi_i, \varphi_{i+1}, \ldots, \varphi_k) \land P \Downarrow_{C, E} \Psi^\prime}
      }
      {(\mathcal{T}, S) \vdash_\CRL (\varphi_1, \ldots, \varphi_{i-1}, \exists X.\, \varphi_i, \varphi_{i+1}, \ldots, \varphi_k) \land P \Downarrow_{C, E} \Psi^\prime}
    \end{align*}
    \caption{Proof System}
    \label{fig:my_label}
\end{figure}



\begin{lemma}
    \begin{align*}
        & (\mathcal{T}, S) \vdash_\CRL \Psi \Downarrow_{C,E} \Psi^\prime \implies \\
        &
        (\mathcal{T}^*, S^* \cup \mathit{flatten}^\exists(E, \Psi^\prime)), \mathit{flatten}^\exists(C, \Psi^\prime) \vdash_\RL
          \mathit{flatten}^\exists(\Psi, \Psi^\prime) 
    \end{align*}
\end{lemma}
\begin{proof}
By induction on the structure of the CRL proof. TODO
\begin{enumerate}
    \item If the proof ends with \emph{Reduce}, then we are done, since $\mathit{flatten}^\exists(\emptyset, \psi^\prime) = \emptyset$.
    
    \item If the proof ends with \emph{Reflexivity}, then we need to prove
    \begin{equation*}
        \mathcal{S}^*, \mathit{flatten}^\exists(E, \psi), \emptyset \vdash_\RL
          \mathit{flatten}^\exists(\psi, \psi) 
    \end{equation*}
    which we do by applying the Reflexivity proof rule.
    
    \item If the proof ends with \emph{Axiom}, then $\psi \in E$,
          and we have to prove that
          \begin{equation*}
            \mathcal{S}^*, \mathit{flatten}^\prime(E, \psi^\prime), \mathit{flatten}^\prime(C, \psi^\prime) \vdash_\RL
            \mathit{flatten}^\prime(\psi, \psi^\prime)               \, .
          \end{equation*}
          By applying the Axiom proof rule of RL, it is enough to show that
          \begin{equation*}
              \mathit{flatten}^\prime(\psi, \psi^\prime) \in \mathit{flatten^\prime}(E, \psi^\prime) \, ,
          \end{equation*}
          which follows from $\psi \in E$.
          
    \item If the proof ends with \emph{Case}, then we have
        \begin{equation*}
            \mathcal{S}^*, \Bar{E}, \Bar{C} \vdash_\RL
            \mathit{flatten}^\exists((\varphi_1, \ldots, \varphi_{i-1}, \varphi_i, \varphi_{i+1}, \ldots, \varphi_k) \land P^\prime, \Psi^\prime)
        \end{equation*}
        and
        \begin{equation*}
            \mathcal{S}^*, \Bar{E}, \Bar{C} \vdash_\RL
            \mathit{flatten}^\exists((\varphi_1, \ldots, \varphi_{i-1}, \psi_i, \varphi_{i+1}, \ldots, \varphi_k) \land P^\prime, \Psi^\prime) 
        \end{equation*}
        as hypotheses, and we have to prove
        \begin{equation*}
            \mathcal{S}^*, \Bar{E}, \Bar{C} \vdash_\RL
            \mathit{flatten}^\exists((\varphi_1, \ldots, \varphi_{i-1}, (\varphi_i \lor \psi_i), \varphi_{i+1}, \ldots, \varphi_k) \land P^\prime, \Psi^\prime)               \, .
        \end{equation*}
        (where $\Bar{E} = \mathit{flatten}^\exists(E, \psi^\prime)$
         and $\Bar{C} = \mathit{flatten}^\exists(C, \psi^\prime)$
        ).
        After simplifications, we get
        \begin{align*}
            \mathcal{S}^*, \Bar{E}, \Bar{C} \vdash_\RL
            &
            \mathit{constrain}(P^\prime, \mathit{mergePatterns}((\varphi_1, \ldots, \varphi_{i-1}, \varphi_i, \varphi_{i+1}, \ldots, \varphi_k)))
            \\ & \Rightarrow^\exists
            \mathit{flatten}(\Psi^\prime)
        \end{align*}
        and
        \begin{align*}
            \mathcal{S}^*, \Bar{E}, \Bar{C} \vdash_\RL
            &
            \mathit{constrain}(P^\prime, \mathit{mergePatterns}((\varphi_1, \ldots, \varphi_{i-1}, \psi_i, \varphi_{i+1}, \ldots, \varphi_k)))
            \\ & \Rightarrow^\exists
            \mathit{flatten}(\Psi^\prime)
        \end{align*}
        as hypotheses,
        and have to prove
        \begin{align*}
            \mathcal{S}^*, \Bar{E}, \Bar{C} \vdash_\RL
            &
            \mathit{constrain}(P^\prime, \mathit{mergePatterns}((\varphi_1, \ldots, \varphi_{i-1}, (\varphi_i \lor \psi_i), \varphi_{i+1}, \ldots, \varphi_k)))
            \\ & \Rightarrow^\exists
            \mathit{flatten}(\Psi^\prime)
        \end{align*}
        Since
        \begin{align*}
            \mathcal{T}^* \vDash_\ML & \mathit{constrain}(P^\prime, \mathit{mergePatterns}((\varphi_1, \ldots, \varphi_{i-1}, (\varphi_i \lor \psi_i), \varphi_{i+1}, \ldots, \varphi_k))) \leftrightarrow \\
            & (\mathit{constrain}(P^\prime, \mathit{mergePatterns}((\varphi_1, \ldots, \varphi_{i-1}, \varphi_i, \varphi_{i+1}, \ldots, \varphi_k))) \\
            & \lor \mathit{constrain}(P^\prime, \mathit{mergePatterns}((\varphi_1, \ldots, \varphi_{i-1}, \psi_i, \varphi_{i+1}, \ldots, \varphi_k))))
        \end{align*}
        (where $\mathcal{S}^* = (\mathcal{T}^*, S)$),
        we can apply the Consequence RL rule on the goal, followed by a Case Analysis rule applied to the two hypotheses, and we are done.
        
    \item If the proof ends with \emph{Step},
      we can assume a patternless FOL formula $P^\prime$, a rule $\varphi \Rightarrow^\exists \varphi^\prime \in S$ such that
      $\mathcal{T} \vDash_\ML \varphi_i \leftrightarrow \mathit{constrain}(P^\prime, \varphi)$,
      and an induction hypothesis
      \begin{align*}
        (&\mathcal{T}^*, S^* \cup \mathit{flatten}^\exists(C \cup E, \Psi^\prime)), \emptyset \vdash_\RL
          \\ &
          \mathit{flatten}((\varphi_1, \ldots, \varphi_{i-1}, \mathit{constrain}(P^\prime, \varphi^\prime), \varphi_{i+1}, \ldots, \varphi_k) \land P) \Rightarrow^\exists \mathit{flatten}(\Psi^\prime)     
      \end{align*}
      and have to construct
      \begin{align*}
      & (\mathcal{T}^*, S^* \cup \mathit{flatten}^\exists(E, \Psi^\prime)), \mathit{flatten}^\exists(C, \Psi^\prime) \vdash_\RL \\
          & \mathit{flatten}((\varphi_1, \ldots, \varphi_{i-1}, \varphi_i, \varphi_{i+1}, \ldots, \varphi_k) \land P) \Rightarrow^\exists \mathit{flatten}(\Psi^\prime)    \, .
      \end{align*}
        By definition of $S^*$, we also have
        \begin{align*}
            (\mathit{heat}(L, \varphi, R) \Rightarrow^\exists \mathit{heat}(L, \varphi^\prime, R)) \in S^* \, .
        \end{align*}
      
    We apply the Transitivity rule with the second premise being our first inductive hypothesis, and it remains to prove the second premise, which is (after simplification)
    \begin{align*}
        & (\mathcal{T}, S)^*, \mathit{flatten}^\exists(E, \psi^\prime), \mathit{flatten}^\exists(C, \psi^\prime)
        \\& \vdash_\RL
        \mathit{constrain}(P, \mathit{mergePatterns}(\varphi_1, \ldots, \varphi_{i-1}, \varphi_i, \varphi_{i+1}, \ldots,                          \varphi_k))
        \\&\quad \Rightarrow^\exists
        \mathit{constrain}(P, \mathit{mergePatterns}(\varphi_1, \ldots, \varphi_{i-1}, \mathit{constrain}(P^\prime, \varphi^\prime), \varphi_{i+1}, \ldots, \varphi_k) ) \, .
    \end{align*}
    By Congruence lemma and our assumption $\mathcal{T} \vDash_\ML \varphi_i \leftrightarrow (\varphi \land \psi)$ (adding the star does not break anything, by conservativeness), we have
    \begin{align*}
        \mathcal{T}^* \vDash_\ML &
        \mathit{constrain}(P, \mathit{mergePatterns}(\varphi_1, \ldots, \varphi_{i-1}, \varphi_i, \varphi_{i+1}, \ldots,                          \varphi_k))
        \\ & \leftrightarrow
        \mathit{constrain}(P, \mathit{mergePatterns}(\varphi_1, \ldots, \varphi_{i-1}, \mathit{constrain}(P^\prime, \varphi), \varphi_{i+1}, \ldots, \varphi_k)) \, ,
    \end{align*}
    and therefore we can apply the Consequence rule on the goal, changing it into
    \begin{align*}
        & (\mathcal{T}, S)^*, \mathit{flatten}^\prime(E, \psi^\prime), \mathit{flatten}^\prime(C, \psi^\prime)
        \\& \vdash_\RL
        \mathit{constrain}(P, \mathit{mergePatterns}(\varphi_1, \ldots, \varphi_{i-1}, \mathit{constrain}(P^\prime, \varphi), \varphi_{i+1}, \ldots,                          \varphi_k))
        \\&\quad \Rightarrow^\exists
        \mathit{constrain}(P, \mathit{mergePatterns}(\varphi_1, \ldots, \varphi_{i-1}, \mathit{constrain}(P^\prime, \varphi^\prime), \varphi_{i+1}, \ldots, \varphi_k)) \, .
    \end{align*}
    Now we apply Consequence again using \Cref{lem:constrainMergeComm},
    changing the goal into
    \begin{align*}
        & (\mathcal{T}, S)^*, \mathit{flatten}^\prime(E, \psi^\prime), \mathit{flatten}^\prime(C, \psi^\prime)
        \\& \vdash_\RL
        \mathit{constrain}(P, \mathit{constrain}(P^\prime, \mathit{mergePatterns}(\varphi_1, \ldots, \varphi_{i-1}, \varphi, \varphi_{i+1}, \ldots, \varphi_k)))
        \\&\quad \Rightarrow^\exists
        \mathit{constrain}(P, \mathit{constrain}(P^\prime, \mathit{mergePatterns}(\varphi_1, \ldots, \varphi_{i-1}, \varphi^\prime, \varphi_{i+1}, \ldots, \varphi_k))) \, .
    \end{align*}
    Now apply Consequence again using \Cref{lem:doubleconstrain},
    changing the goal into
    \begin{align*}
        & (\mathcal{T}, S)^*, \mathit{flatten}^\prime(E, \psi^\prime), \mathit{flatten}^\prime(C, \psi^\prime)
        \\& \vdash_\RL
        \mathit{constrain}(P \land P^\prime, \mathit{mergePatterns}(\varphi_1, \ldots, \varphi_{i-1}, \varphi, \varphi_{i+1}, \ldots, \varphi_k))
        \\&\quad \Rightarrow^\exists
        \mathit{constrain}(P \land P^\prime, \mathit{mergePatterns}(\varphi_1, \ldots, \varphi_{i-1}, \varphi^\prime, \varphi_{i+1}, \ldots, \varphi_k)) \, ,
    \end{align*}
    and once again using \Cref{lem:constrainAsConjunction}, changing the goal into
    \begin{align*}
        & (\mathcal{T}, S)^*, \mathit{flatten}^\prime(E, \psi^\prime), \mathit{flatten}^\prime(C, \psi^\prime)
        \\& \vdash_\RL
        \mathit{mergePatterns}(\varphi_1, \ldots, \varphi_{i-1}, \varphi, \varphi_{i+1}, \ldots, \varphi_k)
        \land (P \land P^\prime)
        \\&\quad \Rightarrow^\exists
        \mathit{mergePatterns}(\varphi_1, \ldots, \varphi_{i-1}, \varphi^\prime, \varphi_{i+1}, \ldots, \varphi_k) \land (P \land P^\prime) \, ,
    \end{align*}
    Now we strip $P \land P^\prime$ by applying Logic Framing, resulting in the goal
    \begin{align*}
        & (\mathcal{T}, S)^*, \mathit{flatten}^\prime(E, \psi^\prime), \mathit{flatten}^\prime(C, \psi^\prime)
        \\& \vdash_\RL
        \mathit{mergePatterns}(\varphi_1, \ldots, \varphi_{i-1}, \varphi, \varphi_{i+1}, \ldots, \varphi_k)
        \\&\quad \Rightarrow^\exists
        \mathit{mergePatterns}(\varphi_1, \ldots, \varphi_{i-1}, \varphi^\prime, \varphi_{i+1}, \ldots, \varphi_k) \, .
    \end{align*}
    We apply Consequence again, changing the goal to
    \begin{align*}
        & (\mathcal{T}, S)^*, \mathit{flatten}^\prime(E, \psi^\prime), \mathit{flatten}^\prime(C, \psi^\prime)
        \\ \vdash_\RL &
        \bigvee_{i_1=1}^{m_1} \ldots \bigvee_{i_{j-1}=1}^{m_{j-1}}
        \bigvee_{i_{j+1}=1}^{m_{j+1}} \ldots \bigvee_{i_n=1}^{m_n}
        \exists \vec{X_1} \ldots \vec{X_{j-1}} \vec{X_{j+1}} \ldots \vec{X_n}
        \\& \exists \vec{X_j} \bigvee_{i_j=1}^{m_j} (\mathit{cfgheat}(L, \phi_{j, i_j}, R) \land P_{j, i_j}
        \\&\quad \land (L = \mathit{mkList}(\phi_{1, i_1}, \ldots, \phi_{j-1, i_{j-1}}))
        \\&\quad \land R = \mathit{mkList}(\phi_{j+1, i_{j+1}}, \ldots, \phi_{n, i_{n}})
        \\&\quad \land (P_{1, i_1} \land \ldots \land P_{j-1, i_{j-1}} \land P_{j+1, i_{j+1}} \land \ldots \land P_{n, i_n}))
        \\ \Rightarrow^\exists &
        \bigvee_{i_1=1}^{m_1} \ldots \bigvee_{i_{j-1}=1}^{m_{j-1}}
        \bigvee_{i_{j+1}=1}^{m_{j+1}} \ldots \bigvee_{i_n=1}^{m_n}
        \exists \vec{X_1} \ldots \vec{X_{j-1}} \vec{X_{j+1}} \ldots \vec{X_n}
        \\& \exists \vec{X^\prime_j} \bigvee_{i^\prime_j=1}^{m^\prime_j} (\mathit{cfgheat}(L, \phi^\prime_{j, i^\prime_j}, R) \land P^\prime_{j, i^\prime_j}
        \\&\quad \land (L = \mathit{mkList}(\phi_{1, i_1}, \ldots, \phi_{j-1, i_{j-1}}))
        \\&\quad \land R = \mathit{mkList}(\phi_{j+1, i_{j+1}}, \ldots, \phi_{n, i_{n}})
        \\&\quad \land (P_{1, i_1} \land \ldots \land P_{j-1, i_{j-1}} \land P_{j+1, i_{j+1}} \land \ldots \land P_{n, i_n}))
    \end{align*}
    where $\exists \vec{X_j}.\, \bigvee_{i_j = 1}^{m_j} (\phi_{i_j} \land P_{i_j}) = \varphi $
    and $\exists \vec{X_j^\prime}.\, \bigvee_{i_j^\prime = 1}^{m_j^\prime} (\phi_{i_j^\prime} \land P_{i_j}^\prime) = \varphi^\prime$.
    Now we iteratively apply Case Analysis, followed by Consequence where on the RHS of $\Rightarrow^\exists$ we select the disjunct corresponding to the LHS.
    We end up with a bunch of goals of the shape
    \begin{align*}
        & (\mathcal{T}, S)^*, \mathit{flatten}^\prime(E, \psi^\prime), \mathit{flatten}^\prime(C, \psi^\prime)
        \\ \vdash_\RL &
        \exists \vec{X_1} \ldots \vec{X_{j-1}} \vec{X_{j+1}} \ldots \vec{X_n}
        \\& \exists \vec{X_j} \bigvee_{i_j=1}^{m_j} (\mathit{cfgheat}(L, \phi_{j, i_j}, R) \land P_{j, i_j}
        \\&\quad \land (L = \mathit{mkList}(\phi_{1, i_1}, \ldots, \phi_{j-1, i_{j-1}}))
        \\&\quad \land R = \mathit{mkList}(\phi_{j+1, i_{j+1}}, \ldots, \phi_{n, i_{n}})
        \\&\quad \land (P_{1, i_1} \land \ldots \land P_{j-1, i_{j-1}} \land P_{j+1, i_{j+1}} \land \ldots \land P_{n, i_n}))
        \\ \Rightarrow^\exists &
        \exists \vec{X_1} \ldots \vec{X_{j-1}} \vec{X_{j+1}} \ldots \vec{X_n}
        \\& \exists \vec{X^\prime_j} \bigvee_{i^\prime_j=1}^{m^\prime_j} (\mathit{cfgheat}(L, \phi^\prime_{j, i^\prime_j}, R) \land P^\prime_{j, i^\prime_j}
        \\&\quad \land (L = \mathit{mkList}(\phi_{1, i_1}, \ldots, \phi_{j-1, i_{j-1}}))
        \\&\quad \land R = \mathit{mkList}(\phi_{j+1, i_{j+1}}, \ldots, \phi_{n, i_{n}})
        \\&\quad \land (P_{1, i_1} \land \ldots \land P_{j-1, i_{j-1}} \land P_{j+1, i_{j+1}} \land \ldots \land P_{n, i_n})) \, .
    \end{align*}
    Now we strip the quantifiers using Abstraction followed by Consequence,
    leading to goals of the shape
    \begin{align*}
        & (\mathcal{T}, S)^*, \mathit{flatten}^\prime(E, \psi^\prime), \mathit{flatten}^\prime(C, \psi^\prime)
        \\ \vdash_\RL &
        \exists \vec{X_j} \bigvee_{i_j=1}^{m_j} (\mathit{cfgheat}(L, \phi_{j, i_j}, R) \land P_{j, i_j}
        \\&\quad \land (L = \mathit{mkList}(\phi_{1, i_1}, \ldots, \phi_{j-1, i_{j-1}}))
        \\&\quad \land R = \mathit{mkList}(\phi_{j+1, i_{j+1}}, \ldots, \phi_{n, i_{n}})
        \\&\quad \land (P_{1, i_1} \land \ldots \land P_{j-1, i_{j-1}} \land P_{j+1, i_{j+1}} \land \ldots \land P_{n, i_n}))
        \\ \Rightarrow^\exists &
        \exists \vec{X^\prime_j} \bigvee_{i^\prime_j=1}^{m^\prime_j} (\mathit{cfgheat}(L, \phi^\prime_{j, i^\prime_j}, R) \land P^\prime_{j, i^\prime_j}
        \\&\quad \land (L = \mathit{mkList}(\phi_{1, i_1}, \ldots, \phi_{j-1, i_{j-1}}))
        \\&\quad \land R = \mathit{mkList}(\phi_{j+1, i_{j+1}}, \ldots, \phi_{n, i_{n}})
        \\&\quad \land (P_{1, i_1} \land \ldots \land P_{j-1, i_{j-1}} \land P_{j+1, i_{j+1}} \land \ldots \land P_{n, i_n})) \, .
    \end{align*}
    Since variables from $\vec{X_j}$ and $\vec{X_j^\prime}$ can occur only in $\phi_{j, i_j}$,
    $\phi^\prime_{j, i_j}$, $P_{j, i_j}$ and $P^\prime_{j, i_j}$, we can change the goals
    (using Consequence) into
    \begin{align*}
        & (\mathcal{T}, S)^*, \mathit{flatten}^\prime(E, \psi^\prime), \mathit{flatten}^\prime(C, \psi^\prime)
        \\ \vdash_\RL &
        (\exists \vec{X_j} \bigvee_{i_j=1}^{m_j} \mathit{cfgheat}(L, \phi_{j, i_j}, R) \land P_{j, i_j})
        \\&\land L = \mathit{mkList}(\phi_{1, i_1}, \ldots, \phi_{j-1, i_{j-1}})
        \\&\land R = \mathit{mkList}(\phi_{j+1, i_{j+1}}, \ldots, \phi_{n, i_{n}})
        \\&\land (P_{1, i_1} \land \ldots \land P_{j-1, i_{j-1}} \land P_{j+1, i_{j+1}} \land \ldots \land P_{n, i_n})
        \\ \Rightarrow^\exists &
        (\exists \vec{X^\prime_j} \bigvee_{i^\prime_j=1}^{m^\prime_j} \mathit{cfgheat}(L, \phi^\prime_{j, i^\prime_j}, R) \land P^\prime_{j, i^\prime_j})
        \\&\land L = \mathit{mkList}(\phi_{1, i_1}, \ldots, \phi_{j-1, i_{j-1}})
        \\&\land R = \mathit{mkList}(\phi_{j+1, i_{j+1}}, \ldots, \phi_{n, i_{n}})
        \\&\land (P_{1, i_1} \land \ldots \land P_{j-1, i_{j-1}} \land P_{j+1, i_{j+1}} \land \ldots \land P_{n, i_n}) \, .
    \end{align*}
    We conclude this case by applying Framing and Axiom.
    
    \item If the proof ends with \emph{Circularity}, we can assume
        \begin{align*}
            (\mathcal{T}^*, S^* \cup \mathit{flatten}^\exists(E, \Psi^\prime)),
            \mathit{flatten}^\exists(C \cup \{ \Psi \}, \Psi^\prime) \vdash_\RL
            \mathit{flatten}^\exists(\Psi, \Psi^\prime)
        \end{align*}
        which simplifies to
        \begin{align*}
            (\mathcal{T}^*, S^* \cup \mathit{flatten}^\exists(E, \Psi^\prime)),
            \mathit{flatten}^\exists(C, \Psi^\prime) \cup \mathit{flatten}^\exists(\{ \Psi \}, \Psi^\prime) \vdash_\RL
            \mathit{flatten}^\exists(\Psi, \Psi^\prime)
        \end{align*}
        and have to prove
        \begin{align*}
            (\mathcal{T}^*, S^* \cup \mathit{flatten}^\exists(E, \Psi^\prime)),
            \mathit{flatten}^\exists(C, \Psi^\prime) \vdash_\RL
            \mathit{flatten}^\exists(\Psi, \Psi^\prime)
        \end{align*}
        which follows from the assumption by Circularity.
        
    \item If the proof ends with \emph{Conseq}, we can assume
    \begin{align*}
        \mathcal{T}^* \vDash_\ML \mathit{flatten}(\Phi) \leftrightarrow \mathit{flatten}(\Phi^\prime)
    \end{align*}
    and
    \begin{align*}
        (\mathcal{T}^*, S^* \cup \mathit{flatten}^\exists(E, \Psi^\prime)), \mathit{flatten}^\exists(C, \Psi^\prime) \vdash_\RL
          \mathit{flatten}^\exists(\Phi^\prime, \Psi^\prime) \, ,
    \end{align*}
    and have to prove
    \begin{align*}
        (\mathcal{T}^*, S^* \cup \mathit{flatten}^\exists(E, \Psi^\prime)), \mathit{flatten}^\exists(C, \Psi^\prime) \vdash_\RL
          \mathit{flatten}^\exists(\Phi, \Psi^\prime)  \, .
    \end{align*}
    The second assumption simplifies to
    \begin{align*}
        (\mathcal{T}^*, S^* \cup \mathit{flatten}^\exists(E, \Psi^\prime)), \mathit{flatten}^\exists(C, \Psi^\prime) \vdash_\RL
          \mathit{flatten}(\Phi^\prime) \Rightarrow^\exists \mathit{flatten}(\Psi^\prime) \, ,
    \end{align*}
    while the goal to
    \begin{align*}
        (\mathcal{T}^*, S^* \cup \mathit{flatten}^\exists(E, \Psi^\prime)), \mathit{flatten}^\exists(C, \Psi^\prime) \vdash_\RL
          \mathit{flatten}(\Phi) \Rightarrow^\exists \mathit{flatten}(\Psi^\prime) \, ;
    \end{align*}
    therefore, we can apply the \emph{Consequence} rule.        
        
    \end{enumerate}
\end{proof}

\section{Implementation}

\bibliography{bibliography}
\bibliographystyle{plain}

\appendix


\end{document}
