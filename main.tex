\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amssymb,mathtools}
\usepackage{thmtools}
\usepackage{hyperref}
% `cleveref` has to be loaded after `hyperref`
\usepackage{cleveref}
\usepackage{stackengine}
\usepackage{minted}
\usepackage{tcolorbox}
\usepackage{prftree}
\usepackage{fancyvrb}
\usepackage{csquotes}
\usepackage{appendix}

\title{Cartesian Reachability Logic}
\author{Jan Tu≈°il }
\date{February 2022}

\declaretheorem[]{example}
\declaretheorem[]{definition}
\declaretheorem[]{lemma}
\declaretheorem[]{theorem}
\declaretheorem[]{proof}
\declaretheorem[]{remark}

\newcommand{\CRL}{\mathsf{CRL}}
\newcommand{\Var}{\mathit{Var}}
\newcommand{\Tcfg}{\mathcal{T}_{\mathit{Cfg}}}

\newcommand\oast{\stackMath\mathbin{\stackinset{c}{0ex}{c}{0ex}{\ast}{\bigcirc}}}

\begin{document}

\maketitle

\section{Introduction}

\section{Preliminaries}

\subsection{(Topmost, $\mu$-free) Matching Logic}

\subsection{All-path Reachability Logic}



\begin{definition}[\cite{StefanescuCMMSR19}]
We define reachability-logic signatures, rules, and systems as follows.
\begin{enumerate}
    \item A reachability-logic \emph{signature} is a pair $(\Sigma, \mathit{Cfg})$,
          where $\Sigma$ is a matching logic signature and $\mathit{Cfg}$ is a sort.
          
    \item A \emph{one-path reachability rule} over reachability logic signature $(\Sigma, \mathit{Cfg})$        is a pair $\varphi \Rightarrow^\exists \varphi^\prime$,
          where $\varphi$ and $\varphi^\prime$
          are patterns (which can have free variables) of sort $\mathit{Cfg}$.
          
    \item A \emph{reachability system} over a reachability-logic signature $(\Sigma, \mathit{Cfg})$
          is a pair $\mathcal{S} = (\mathcal{T}, S)$, where $\mathcal{T}$ is a $\Sigma$-algebra
          and $S$ is a set of reachability rules over $(\Sigma, \mathit{Cfg})$.
          
    \item A rule $\varphi \Rightarrow^\exists \varphi^\prime$ over $(\Sigma, \mathit{Cfg})$
          is \emph{weakly well-defined}
          with respect to $\Sigma$-algebra $\mathcal{T}$
          iff
          for any $\gamma \in \Tcfg$ and $\rho : \Var \to \mathcal{T}$
          with $(\gamma, \rho) \vDash \varphi$,
          there exists $\gamma^\prime \in \Tcfg$ with $(\gamma^\prime , \rho) \vDash \varphi^\prime$.
          
    \item A reachability system $\mathcal{S}$ is \emph{weakly well-defined} iff each its rule is weakly     
          well-defined.
          
    \item A reachability system $\mathcal{S} = (\mathcal{T}, S)$ over $(\Sigma, \mathit{Cfg})$ induces
          a \emph{transition system} \\
          $(\Tcfg , \Rightarrow_{\mathcal{S}})$,
          where $\gamma \Rightarrow_{\mathcal{S}} \gamma^\prime$
          for $\gamma, \gamma^\prime \in \Tcfg$
          iff there is some rule \\ $\varphi \Rightarrow^\exists \varphi^\prime \in S$
          and some valuation $\rho : \Var \to \mathcal{T}$ with $(\gamma, \rho) \vDash \varphi$
          and $(\gamma^\prime , \rho) \vDash \varphi^\prime$.
          
    \item A \emph{$\Rightarrow_{\mathcal{S}}$-path} is a finite
          sequence $\gamma_0 \Rightarrow_{\mathcal{S}} \gamma_1 \Rightarrow_{\mathcal{S}} \ldots \Rightarrow_{\mathcal{S}} \gamma_n$
          with $\gamma_0,\ldots,\gamma_n \in \Tcfg$.
          
    \item A $\Rightarrow_{\mathcal{S}}$-path is \emph{complete}
          iff it is not a strict prefix of any
          other $\Rightarrow_{\mathcal{S}}$-path.
\end{enumerate}

\end{definition}

\section{Cartesian Reachability Logic}

We need to make the definition such that it works with reachability logic for the composite semantics.
Here is one attempt:
\begin{definition}\label{def:CRLsemantics}
A Cartesian reachability rule
$(\varphi_1,\ldots,\varphi_k) \land \varphi \Rightarrow^{c\forall} (\psi_1,\ldots,\psi_k) \land \psi$
of arity $k$
is \emph{valid},
written
$\vDash_\CRL (\varphi_1,\ldots,\varphi_k) \land \varphi \Rightarrow^{c\forall}
(\psi_1,\ldots,\psi_k) \land \psi$,
iff for all configurations $\sigma_1,\ldots,\sigma_k$ and any valuation $\rho$,
whenever $\sigma_1 \in |\varphi_1 \land \varphi|_\rho \land \ldots \land \sigma_k \in |\varphi_l \land \varphi|_\rho$,
then for every complete (that is, finite terminating) executions $\pi_1, \ldots, \pi_k$ such that
$\sigma_1 = \pi_1(0) \land \ldots \land \sigma_k = \pi_k(0)$ there exists $i_1,\ldots,i_k \in \mathbb{N}$
such that
$\pi_1(i_1) \in |\varphi_1 \land \psi|_\rho \land \ldots \land \pi_k(i_k) \in |\varphi_k \land \psi|_\rho$.
\end{definition}

TODOs:
\begin{itemize}
    \item Validate this definition against examples from the CHL paper.
    \item Have a "running example" - some programming language, like IMP?
    \item Define the 'composite' semantics - list of configurations in one configuration.
    \item Have an example how do we perform lockstep execution on ifs.
    \item Why there are the pluses on both premises of the Circularity proof rule of the Equiv checking paper? Do we need it? Maybe we may lose/miss some synchronization point if we require both. We probably need to weaken the premises.
    \item Conservativeness argument for the additional rules.
\end{itemize}

\begin{definition}
We translate a language semantics into a semantics for lists of configurations as follows.
\begin{enumerate}
    \item Let $(\Sigma, \mathit{Cfg})$ be a reachability-logic signature.
          Then $(\Sigma, \mathit{Cfg})^*$ = $(\Sigma^*, \mathit{Cfg}^*)$,
          where
          \begin{enumerate}
              \item $\Sigma^* = \Sigma \cup \{ \mathit{cfgitem}, \mathit{cfgconcat},
          %\mathit{cfgdummy},
          \mathit{cfgheat} \}$
              \item $\mathit{Cfg}^*$ is a fresh sort (representing the sort of lists of configurations);
              %\item $\mathit{cfgdummy}$ is a fresh symbol of sort $\mathit{Cfg}$;
              \item $\mathit{cfgitem}$ a fresh symbol of sort $\mathit{Cfg} \to \mathit{Cfg}^*$;
              \item $\mathit{cfgconcat}$ a fresh symbol of sort $\mathit{Cfg}^* \times \mathit{Cfg}^* \to \mathit{Cfg}^*$; and
              \item $\mathit{cfgheat}$ is a fresh symbol of sort $\mathit{Cfg}^* \times \mathit{Cfg} \times \mathit{Cfg}^* \to \mathit{Cfg}^*$.
          \end{enumerate}
    \item Let $S$ be a set of reachability rules over $(\Sigma, \mathit{Cfg})$.
          We generate a set of reachability rules $S^*$ over $(\Sigma, \mathit{Cfg})^*$
          by setting
          \begin{equation*}
              S^* = \{ \mathit{cfgheat}(L, \varphi_1, R) \land P \Rightarrow^\exists \mathit{cfgheat}(L, \varphi_2, R) \land P^\prime \mid (\varphi_1 \land P \Rightarrow^\exists \varphi_2 \land P^\prime) \in S \} \, ,
          \end{equation*}
          where $L,R$ are distinct fresh variables (not occurring in any rule in $S$).
    \item Let $\mathcal{T}$ be a configuration model; that is, a $\Sigma$-algebra.
          We generate a $\Sigma^*$-algebra $\mathcal{T}*$, which interprets all sorts and symbols from
          $\Sigma$ as in $\mathcal{T}$, and in addition interprets
          \begin{enumerate}
              \item the sort $\mathit{Cfg}*$ as the set of all finite lists
              $[c_1;\ldots;c_n]$ for $n \in \mathbb{N}$, where $c_i$ is an element of sort $\mathit{Cfg}$
              for any $0 \leq i \leq n$;
              \item the symbol $\mathit{cfgitem}$ as the function $\lambda c.\, [c]$;
              \item the symbol $\mathit{cfgconcat}$ as the function $\lambda l_1,l_2.\, l_1 \texttt{++} l_2$,
                where $\texttt{++}$ is list concatenation; and
              \item the symbol $\mathit{cfgheat}$ as the function
                $\lambda l_1, c, l_2.\, l_1 \texttt{++} [c] \texttt{++} l_2$.
          \end{enumerate}
          
    \item Let $\mathcal{S} = (\mathcal{T}, S)$ be a reachability system over $(\Sigma, \mathit{Cfg})$.
          We generate a reachability system $\mathcal{S}^*$ over $(\Sigma, \mathit{Cfg})^*$
          by setting $\mathcal{S}^* = (\mathcal{T}^*, S^*)$.
\end{enumerate}
\end{definition}

\begin{lemma}
    Let $\mathcal{S} = (\mathcal{T}, S)$ be a reachability-logic system over $(\Sigma, \mathit{Cfg})$.
    For any $k \geq 1$, any configurations $c_1,\ldots,c_k$
\end{lemma}

\section{Implementation}

\bibliography{bibliography}
\bibliographystyle{plain}

\appendix

\section{Some old thoughts}

An option would be to come up with a language-agnostic way of composing two programs in such a way
that the composition is still executable.
In particular, given a matching logic signature $\Sigma$ and a reachability logic theory $S$, one may
want to construct a signature $\Sigma^\prime = \Sigma \cup \{ \mathit{prod} \}$
(where $\mathit{prod}$ is a fresh symbol)
and a theory $S^\prime$ such that for any $\mu$-free patterns $\varphi_1,\varphi_2,\psi_1,\psi_2$
it holds that $S \vdash \varphi_1 \Rightarrow^\exists \psi_1$ and
$S \vdash \varphi_2 \Rightarrow^\exists \psi_2$ if and only if
\begin{equation*}
S^\prime \vdash \mathit{prod}\ \varphi_1\ \varphi_2 \Rightarrow^\exists \mathit{prod}\ \psi_1\ \psi_2    \, .
\end{equation*}
%We may also want $S^\prime$ to be deterministic whenever $S$ is.

Next, we need to find a generalization of Cartesian Hoare triples.
Something like the following might suffice:
The idea behind the above definition is that $\varphi,\psi$ are predicate patterns
that constraints the relationship between the configurations.
I would then want to come up with a (language-parametric) proof system
for deriving claims of the shape
$\vdash_\CRL (\varphi_1,\ldots,\varphi_k) \land \varphi \Rightarrow^{c\exists}
(\psi_1,\ldots,\psi_k) \land \psi$;
similarly to CHL, the proof system should have a \emph{linearization} property,
meaning that a claim could be derived if and only if
a linearized claim (using the composition with $\textit{prod}$ described above) could be derived in reachability logic.

Then I would need to overcome the following three challenges:
\begin{enumerate}
    \item to extend the above definition with axioms and circularities, as in reachability logic;
    \item to create a rule (or set of rules) playing the role of the Fusion rule from CHL; and
    \item to support non-deterministic operations and go all-path.
\end{enumerate}

\section{Questions}

The CHL paper has a lemma saying that sequential composition commutes (assuming the two statements use non-overlapping sets of variables).
We need something similar. What would be our equivalent? Basically, that
$\mathit{prod} c_1 c_2$ satisfies the same set of reachability claims as $\mathit{prod} c_2 c_1$?
Also, what is the relationship between the product program in product semantics and the original program? What is the semantics of the CRL claim - is it defined using only the semantics of the original program in original language? (I think so.) So we first need to define language independent product programs/semantics and prove properties about them.

Can we verify some property of a heap manipulating program? Say, 'monotonicity' of sum with list append?


\Cref{def:CRLsemantics} uses pairs inside matching logic. Maybe we should rephrase it so that it talks about valuations instead.

\section{Product programs and their semantics}
We represent a programming language semantics as a reachability system.
\begin{definition}\label{def:RLsystem}
A \emph{reachability system} $\mathcal{S}$ is a triple $(\Sigma, \mathcal{M}, S)$, where
\begin{enumerate}
    \item $\Sigma$ is a matching logic signature;
    \item $\mathcal{M}$ is a matching logic $\Sigma$-model; and
    \item $S$ is a set of \emph{reachability rules} of the shape
    $\varphi_1 \Rightarrow^\exists \varphi_2$, where $\varphi_1,\varphi_2$ are matching logic $\Sigma$-patterns.
\end{enumerate}
\end{definition}

\begin{definition}\label{def:RLproduct}
Given a reachability system $\mathcal{S} = (\Sigma, \mathcal{M}, S)$
where $\mathcal{M} = (M, \{\sigma_M\}_{\sigma \in \Sigma}, @_M)$,
we define a \emph{self-product system}
$\mathcal{S}\oast{}\mathcal{S} = (\Sigma\oast{}\Sigma, \mathcal{M}\oast{}\mathcal{M}, S\oast{}S)$ as follows.
\begin{enumerate}
    \item $\Sigma\oast{}\Sigma = \Sigma \cup \{ \mathit{prod} \}$, where $\mathit{prod}$ is a fresh symbol not occurring in $\Sigma$;
    \item $\mathcal{M}\oast{}\mathcal{M} = (M\oast{}M, \{\sigma_{M\oast{}M}\}_{\sigma \in \Sigma\oast{}\Sigma}, @_{M\oast{}M})$, where
    \begin{enumerate}
        \item $M\oast{}M = M \cup \{ \mathrm{\#prod} \} \cup (\{ \mathrm{\#prod} \} \times M) \cup (\{ \mathrm{\#prod} \} \times M \times M)$, where $\mathrm{\#prod}$ is a fresh element not occurring in $M$; 
        \item $\sigma_{\mathcal{M} \oast \mathcal{M}} = \sigma_M$ for any $\sigma \in \Sigma$;
        \item $\sigma_{\mathit{prod}} = \{ \mathrm{\#prod} \}$;
        \item $m_1 @_{M\oast{}M} m_2 = m_1 @_M m_2$ whenever $m_1,m_2 \in M$;
        \item $\mathrm{\#prod} @_{M\oast{}M} m_1 = (\mathrm{\#prod}, m_1)$ whenever $m_1 \in M$;
        \item $(\mathrm{\#prod}, m_1) @_{M\oast{}M} m_2 = (\mathrm{\#prod}, m_1, m_2)$ whenever $m_2 \in M$; and
        \item $m_1 @_{M\oast{}M} m_2 = \emptyset$ otherwise.
    \end{enumerate}
    \item
    \begin{align*}
        S \oast{} S &= \{ (\mathit{prod}\ \mathit{lift}(\varphi)\ x) \Rightarrow^\exists (\mathit{prod}\ \mathit{lift}(\psi)\ x) \mid \varphi \Rightarrow^\exists \psi \in S \} \\
                     & \cup \{ (\mathit{prod}\ x\ \mathit{lift}(\varphi)) \Rightarrow^\exists (\mathit{prod}\ x\ \mathit{lift}(\psi)) \mid \varphi \Rightarrow^\exists \psi \in S \}  \, .
    \end{align*}
    where $x$ is some element variable not occurring in $S$ and $\mathit{lift(\varphi)}$ is defined recursively as follows:
    \begin{itemize}
        \item $\mathit{lift}(x) \equiv ((x \in \mathit{OLD}) \land x) \lor ((x \not\in \mathit{OLD}) \land s_0)$
        \item $\mathit{lift}(\varphi_1 \rightarrow \varphi_2) \equiv (\mathit{lift}(\varphi_1) \rightarrow \mathit{lift}(\varphi_2)) \land \mathit{OLD}$
        \item $\mathit{lift}(\exists x.\, \varphi) \equiv \exists x.\, x \in \mathit{OLD} \land \mathit{lift}(\varphi)$
        \item $\mathit{lift}(\bot) \equiv \bot$
        \item $\mathit{lift}(s) \equiv s$
        \item $\mathit{lift}(\varphi_1 \ \varphi_2) \equiv \mathit{lift}(\varphi_1) \ \mathit{lift}(\varphi_2)$
    \end{itemize}
    where
        \begin{equation*}
            \mathit{OLD} \equiv \neg (\mathit{prod} \lor (\mathit{prod}\ \top) \lor (\mathit{prod}\ \top\ \top))
        \end{equation*}
    and the membership operator is the standard syntactic sugar on top of the definedness symbol $\mathit{def}$.
    (We do not need to consider the $X$ and $\mu X.\, \varphi$ cases, because the patterns in question are $\mu$-free.)
\end{enumerate}
\end{definition}

\end{document}
