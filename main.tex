\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amssymb,mathtools}
\usepackage{amsthm}
\usepackage{thmtools}
\usepackage{hyperref}
% `cleveref` has to be loaded after `hyperref`
\usepackage{cleveref}
\usepackage{stackengine}
\usepackage{minted}
\usepackage{tcolorbox}
\usepackage{multicol}
\usepackage{prftree}
\usepackage{fancyvrb}
\usepackage{csquotes}
\usepackage{appendix}
\usepackage{todonotes}

\newcommand{\traian}[1]{\todo[author=Traian]{#1}}

\title{Cartesian Reachability Logic}
\author{Jan Tu\v{s}il \and Xiaohong Chen \and Traian Florin Șerbănuță
%\and Jan Obdrzalek
}
\date{\today}

\declaretheorem[]{example}
\declaretheorem[]{definition}
\declaretheorem[]{lemma}
\declaretheorem[]{theorem}
\declaretheorem[]{remark}

\newcommand{\K}{$\mathbb{K}$}
\newcommand{\RL}{\mathsf{RL}}
\newcommand{\ML}{\mathsf{ML}}
\newcommand{\CRL}{\mathsf{CRL}}
\newcommand{\FOL}{\mathsf{FOL}}
\newcommand{\FOLeq}{\FOL_{=}}
\newcommand{\Var}{\mathit{Var}}
\newcommand{\Tcfg}{\mathcal{T}_{\mathit{Cfg}}}
\newcommand{\Pattern}{\mathsf{Pattern}}

\newcommand\oast{\stackMath\mathbin{\stackinset{c}{0ex}{c}{0ex}{\ast}{\bigcirc}}}

\begin{document}

\maketitle

\section{Introduction}

\emph{Reachability logic} (RL) \cite{RosuS12oopsla,RosuSCM13lics,StefanescuCMMSR19}
is a
formalism for reasoning about partial correctness of software, in the spirit of Hoare logics.
Being implemented in the \K{} framework \cite{KVision},
its biggest advantage is that reachability logic is \emph{language independent}:
its proof system can be used unchanged to reason about programs in any language,
as long as the language has a formal semantics in RL.
Through \K{}, reachability logic has been used to build verifiers for real-world languages,
such as C (\cite{RVMatch}), Java (\cite{StefanescuPYLR16VerifiersForAll}), Javascript (\cite{StefanescuPYLR16VerifiersForAll}),
and EVM (\cite{KevmVerificationTool}).
A fundamental limitation of reachability logic is that it is limited to partial correctness properties.
In particular, neither RL nor \K{} can handle \emph{hyperproperties}.

A hyperproperty is a set of \emph{sets of} execution traces, with the following semantics:
a system $S$ (a set of traces) satisfies a hyperproperty $H$ iff $S \in H$.
Hyperproperties are strictly more expressive then properties; for example, many security policies
of interest are hyperproperties but not properties.
Techniques and tools for verifying hyperproperties of software have been developed.
In particular, \emph{Cartesian Hoare logic} (CHL, \cite{SousaD16}) extends Hoare logic
to reason about \emph{$k$-safety hyperproperties}
(a hyperproperty is a \emph{$k$-safety hyperproperty} if its violation can be witnessed
by a set of traces of size $k$).
Also, a game-based technique for verifying software hyperproperties beyond $k$-safety
has been developed in \cite{BeutnerF22}.

A question arises: can these techniques be used in a language-independent setting?
Cartesian Hoare logic, being a kind of a Hoare logic, is tied to a particular imperative language,
so it cannot be used for a different language as is.
On the other hand, the technique developed in \cite{BeutnerF22} works with \emph{symbolic transition systems},
so it already is language-independent \emph{in some sense}. However, it is not clear how to use the technique
with an arbitrary language $L$, without writing a compiler from $L$ to symbolic transition systems first.

In this paper we develop a logic named \emph{Cartesian Reachability logic}, which extends reachability logic
to allow reasoning about $k$-safety hyperproperties. Simiarly to CHL, CRL has a sound
and relatively complete proof system. However, an advantage of CRL against CHL is that it works with any language
for which RL works; that is, with any language which has a RL-based semantics.

\section{Preliminaries}

\subsection{($\mu$-free) Matching Logic}

We work with a variant of matching logic described in
\cite{StefanescuCMMSR19,RosuSCM13lics}.

\begin{definition}[Matching logic syntax and semantics]
We define the matching logic syntax and semantics as follows.
\begin{enumerate}
    \item A matching logic \emph{signature} $\mathbf{\Sigma} = (\Sigma, \mathit{Var})$ is a many-sorted algebraic signature $\Sigma$ together with a sort-wise infinite set of variables $\mathit{Var}$.
    \item Let $T_{\Sigma}(\mathit{Var})$ denote the free $\Sigma$-algebra of terms with variables 
          in $\mathit{Var}$.
          Let $T_{\Sigma, s}(\mathit{Var})$ denote the set of $\Sigma$-terms (with variables in $\mathit{Var})$ of sort $s$.
    \item Let $\mathcal{T}$ be a $\Sigma$-algebra, and $f$ be a symbol from $\Sigma$.
          We use the notation $\mathcal{T}_f$ to denote the interpretation of $f$ in $\mathcal{T}$.
    \item A function $\rho : \mathit{Var} \to \mathcal{T}$, where $\mathcal{T}$ is a $\Sigma$-algebra,
          extends uniquely (in the usual way) to a $\Sigma$-algebra morphism
          $\rho : T_{\Sigma}(\mathit{Var}) \to \mathcal{T}$.
    \item The set of \emph{nullary predicate symbols} $P_\epsilon((\Sigma, \mathit{Var}))$
          (or just $P_\epsilon$ if $(\Sigma, \mathit{Var})$ is known from the context) is
          defined to contain exactly terms $\phi \in T_{\Sigma, s}(\mathit{Var})$.
    \item A matching logic $(\Sigma, \mathit{Var})$-formula (aka $(\Sigma, \mathit{Var})$-\emph{pattern})
          of sort $s$
          is a $(\Sigma, P_\epsilon)-\FOLeq$ formula (that is, a $\FOLeq$ formula where function symbols are
          exactly symbols from $\Sigma$, and where nullary predicate symbols are exactly
          terms $\phi \in T_{\Sigma, s}(\mathit{Var})$, without any $k$-ary predicate symbols for $k > 0$).
          We let $\Pattern(\mathbf{\Sigma})$ (or just $\Pattern$ when $\mathbf{\Sigma}$ is known from the context)
          denote the set of all $\mathbf{\Sigma}$-patterns.
    \item A matching logic pattern is \emph{structureless} if it contains
          no terms $\phi \in T_{\Sigma, s}(\mathit{Var})$ used as predicates.
    \item A \emph{constrained term} is a pattern of the form $\phi \land P$,
          where $\phi \in T_{\Sigma, s}(\mathit{Var})$ and $P$ a structureless pattern.
    \item A matching logic $\Sigma$-\emph{model} $\mathcal{T}$ is a $\Sigma$-algebra.
    \item A matching logic \emph{semantics} is given by means of
          the satisfaction relation $\vDash_{\ML}$ between a matching logic $\Sigma$-model,
          a model element, and a valuation,
          defined inductively as
          \begin{itemize}
              \item $(\mathcal{T}, \gamma, \rho) \vDash \phi$ iff $\gamma = \rho(\pi)$, where $\phi \in T_{\Sigma, s}(\mathit{Var})$;
              \item $(\mathcal{T}, \gamma, \rho) \vDash \varphi_1 \land \varphi_2$ iff
                $(\mathcal{T}, \gamma, \rho) \vDash \varphi_1$ and
                $(\mathcal{T}, \gamma, \rho) \vDash \varphi_2$;
              \item $(\mathcal{T}, \gamma, \rho) \vDash \neg \varphi$ iff
                $(\mathcal{T}, \gamma, \rho) \not\vDash \varphi$;
              \item $(\mathcal{T}, \gamma, \rho) \vDash \exists x : s.\, \varphi$ iff
                $(\mathcal{T}, \gamma, \rho^\prime) \vDash \varphi$ for some $\rho^\prime$ such that
                $\rho^\prime(y) = \rho(y)$ for all $y \in \mathit{Var} \setminus \{ x \}$
                and $\rho^\prime(x) \in \mathcal{T}_s$;
          \end{itemize}
          
\end{enumerate}

\end{definition}


\subsection{One-path Reachability Logic}



\begin{definition}[\cite{StefanescuCMMSR19,RosuS12oopsla}]\label{def:basics}
We define reachability-logic signatures, rules, and systems as follows.
\begin{enumerate}
    \item A reachability-logic \emph{signature} is a pair $(\mathbf{\Sigma}, \mathit{Cfg})$,
          where $\mathbf{\Sigma}$ is a matching logic signature and $\mathit{Cfg}$ is a sort from $\mathbf{\Sigma}$.
          
    \item A \emph{one-path reachability rule} over reachability logic signature $(\mathbf{\Sigma}, \mathit{Cfg})$        is a pair $\varphi \Rightarrow^\exists \varphi^\prime$,
          where $\varphi$ and $\varphi^\prime$
          are $\mathbf{\Sigma}$-patterns (which can have free variables) of sort $\mathit{Cfg}$.
          
    \item A \emph{reachability system} over a reachability-logic signature $((\Sigma, \mathit{Var}), \mathit{Cfg})$
          is a pair $\mathcal{S} = (\mathcal{T}, S)$, where $\mathcal{T}$ is a $\Sigma$-algebra
          and $S$ is a set of reachability rules over $((\Sigma, \mathit{Var}), \mathit{Cfg})$.
          
    \item A rule $\varphi \Rightarrow^\exists \varphi^\prime$ over $((\Sigma, \mathit{Var}), \mathit{Cfg})$
          is \emph{weakly well-defined}
          with respect to $\Sigma$-algebra $\mathcal{T}$
          iff
          for any $\gamma \in \Tcfg$ and $\rho : \Var \to \mathcal{T}$
          with $(\gamma, \rho) \vDash \varphi$,
          there exists $\gamma^\prime \in \Tcfg$ with $(\gamma^\prime , \rho) \vDash \varphi^\prime$.
          
    \item A reachability system $\mathcal{S}$ is \emph{weakly well-defined} iff each its rule is weakly     
          well-defined.
          
    \item A reachability system $\mathcal{S} = (\mathcal{T}, S)$ over $((\Sigma, \mathit{Var}), \mathit{Cfg})$ induces
          a \emph{transition system} \\
          $(\Tcfg , \Rightarrow_{\mathcal{S}})$,
          where $\gamma \Rightarrow_{\mathcal{S}} \gamma^\prime$
          for $\gamma, \gamma^\prime \in \Tcfg$
          iff there is some rule \\ $\varphi \Rightarrow^\exists \varphi^\prime \in S$
          and some valuation $\rho : \Var \to \mathcal{T}$ with $(\gamma, \rho) \vDash \varphi$
          and $(\gamma^\prime , \rho) \vDash \varphi^\prime$.

    \item A reachability system $(\mathcal{T}, S)$ is \emph{deterministic} iff the induced transition system
          is deterministic.

    \item A configuration $\gamma \in \Tcfg$ \emph{terminates} in $(\Tcfg , \Rightarrow_{\mathcal{S}})$
          iff there is no infinite $\Rightarrow_{\mathcal{S}})$-sequence starting with $\gamma$.
          
    \item A \emph{$\Rightarrow_{\mathcal{S}}$-path} is a finite
          sequence $\gamma_0 \Rightarrow_{\mathcal{S}} \gamma_1 \Rightarrow_{\mathcal{S}} \ldots
          \Rightarrow_{\mathcal{S}} \gamma_n$
          with $\gamma_0,\ldots,\gamma_n \in \Tcfg$.
          
    \item A $\Rightarrow_{\mathcal{S}}$-path is \emph{complete}
          iff it is not a strict prefix of any
          other $\Rightarrow_{\mathcal{S}}$-path.

    \item \label{def:oprlSemantics}
          A one-path reachability rule $\varphi \Rightarrow^\exists \varphi^\prime$ is \emph{satisfied}
          in a reachability system $\mathcal{S} = (\mathcal{T}, S)$,
          written $\mathcal{S} \vDash_\RL \varphi \Rightarrow^\exists \varphi^\prime$,
          iff for every $\gamma \in \Tcfg$
          such that $\gamma$ terminates in $(\Tcfg, \Rightarrow_{\mathcal{S}})$
          and for any valuation $\rho : \Var \to \mathcal{T}$
          such that $(\gamma, \rho) \vDash \varphi$,
          there exists some $\gamma^\prime \in \Tcfg$
          such that
          $\gamma \Rightarrow^{*}_{\mathcal{S}} \gamma^\prime$
          and $(\gamma^\prime, \rho) \vDash \varphi^\prime$.
          
%    \item An \emph{all-path reachability rule} is a pair
%        $\varphi \Rightarrow^\forall \varphi^\prime$ of patterns $\varphi$ and $\varphi^\prime$.
%    
%    \item \label{def:aprlSemantics}
%          An all-path reachability rule $\varphi \Rightarrow^\forall \varphi^\prime$ is \emph{satisfied},
%          written $\mathcal{S} \vDash_\RL \varphi \Rightarrow^\forall \varphi^\prime$,
%          iff for all complete $\Rightarrow_{\mathcal{S}}$-paths $\tau$
%          starting with $\gamma \in \Tcfg$ and for all $\rho : \Var \to \mathcal{T}$
%          such that $(\gamma, \rho) \vDash \varphi$,
%          there exists some $\gamma^\prime \in \tau$
%          such that $(\gamma^\prime, \rho) \vDash \varphi^\prime$.
\end{enumerate}

\begin{figure}
    \centering
    \includegraphics[width=0.5\textwidth]{img/onepath-rl.png}
    \caption{One-path reachability-logic proof system.
    The use of $\Rightarrow^+$ in sequent means that it was derived without Reflexivity.
    TODO retypeset}
    \label{fig:RLproofsystem}
\end{figure}

We have RL sequents of the shape
$\mathcal{T}, A, C \vdash_\RL \varphi \Rightarrow^\exists \varphi^\prime$.

\end{definition}

\begin{remark}
For simplicity, we restrict the class of reachability systems we work with to those whose reachability rules
have only disjunctions of constrained terms. That is, we assume all rules have the shape
\begin{equation*}
    \exists \vec{X}.\, \bigvee_{i=1}^{m} (\phi_i \land P_i) \Rightarrow^\exists \exists \vec{Y}.\, \bigvee_{j=1}^{n} (\phi^\prime_j \land P^\prime_j) \, .
\end{equation*}
\end{remark}

\begin{remark}
We do not allow the reachability system to take steps which do not have any effect.
Formally, we assume that for any two configurations
$\sigma, \sigma^\prime \in \mathcal{T}_{\mathit{Cfg}}$, if
$\sigma \Rightarrow_{\mathcal{S}} \sigma^\prime$, then $\sigma \not = \sigma^\prime$.
\end{remark}

\section{Cartesian Reachability Logic}
Cartesian reachability logic is an extension of (one-path) reachability logic.

\begin{definition}[One-Path Cartesian Reachability Rule]\label{def:opCRLsemantics}
A One-Path Cartesian reachability rule
$(\varphi_1,\ldots,\varphi_k) \land \varphi \Rightarrow^{c\exists} (\psi_1,\ldots,\psi_k) \land \psi$
of arity $k$
is \emph{valid} in a reachability system $\mathcal{S} = (\mathcal{T}, S)$,
written
$\mathcal{S} \vDash_\CRL (\varphi_1,\ldots,\varphi_k) \land \varphi \Rightarrow^{c\exists}
(\psi_1,\ldots,\psi_k) \land \psi$,
iff for all configurations $\gamma_1,\ldots,\gamma_k \in \Tcfg$
which terminate in $(\Tcfg, \Rightarrow_{\mathcal{S}})$
and any $\mathcal{T}$-valuation $\rho$,
whenever $(\gamma_1,\rho) \vDash \varphi_1 \land \varphi$ and \ldots
and $(\gamma_k,\rho) \vDash \varphi_k \land \varphi$,
then there exist configurations $\gamma_1^\prime,\ldots,\gamma_k^\prime \in \Tcfg$
such that $\gamma_1 \Rightarrow^{*}_{\mathcal{S}} \gamma_1^\prime$
and \ldots and $\gamma_k \Rightarrow^{*}_{\mathcal{S}} \gamma_k^\prime$,
and
$(\gamma_1^\prime,\rho) \vDash \psi_1 \land \psi$ and \ldots and $(\gamma_k^\prime, \rho) \vDash \psi_k \land \psi$.
\end{definition}

% TODO remark that this is not the same as k "normal" reachability rules.
% An example (monotonicity from the file)

\begin{remark}
\Cref{def:opCRLsemantics} extends \Cref{def:oprlSemantics} of \Cref{def:basics}:
if we fix $k=1$, then
\begin{align*}
    (\mathcal{T}, S) \vDash_\CRL
    (\varphi_1) \land \top  \Rightarrow^{c\exists}
    (\psi_1) \land \top
    \iff
    (\mathcal{T}, S) \vDash_\RL \varphi_1 \Rightarrow^{\exists} \psi_1 \, .
\end{align*}
\end{remark}

%\begin{definition}[All-Path Cartesian Reachability Rule]\label{def:apCRLsemantics}
%An all-path Cartesian reachability rule
%$(\varphi_1,\ldots,\varphi_k) \land \varphi \Rightarrow^{c\forall} (\psi_1,\ldots,\psi_k) \land \psi$
%of arity $k$
%is \emph{valid} in a reachability system $\mathcal{S} = (\mathcal{T}, S)$,
%written
%$\mathcal{S} \vDash_\CRL (\varphi_1,\ldots,\varphi_k) \land \varphi \Rightarrow^{c\forall}
%(\psi_1,\ldots,\psi_k) \land \psi$,
%iff for all configurations $\sigma_1,\ldots,\sigma_k \in \Tcfg$ \traian{Why $\sigma$ instead of $\gamma$?}
%and any $\mathcal{T}$-valuation $\rho$,
%whenever $(\sigma_1, \rho) \vDash \varphi_1 \land \varphi$ and \ldots
%and $(\sigma_k, \rho) \vDash \varphi_k \land \varphi$,
%then for every $k$-tuple of complete paths $(\pi_1, \ldots, \pi_k)$
%such that
%$\sigma_1 = \pi_1(0) \land \ldots \land \sigma_k = \pi_k(0)$,
%there exist indices $i_1, \ldots, i_k$ such that
%$(\pi_1(i_1), \rho) \vDash \varphi_1 \land \psi$ and \ldots and $(\pi_k(i_k), \rho) \vDash \varphi_k \land \psi$.
%\end{definition}

\begin{definition}
We translate a language semantics into a semantics for lists of configurations as follows.
\begin{enumerate}
    \item Let $((\Sigma, \mathit{Var}), \mathit{Cfg})$ be a reachability-logic signature.
          Then $((\Sigma, \mathit{Var}), \mathit{Cfg})^*$ = $((\Sigma^*, \mathit{Var}), \mathit{Cfg}^*)$,
          where
          \begin{enumerate}
              \item $\Sigma^* = \Sigma \cup \{ \mathit{cfgitem}, \mathit{cfgconcat},
          %\mathit{cfgdummy},
          \mathit{cfgheat},
          \mathit{cfgnil} \}$
              \item $\mathit{Cfg}^*$ is a fresh sort (representing the sort of lists of configurations);
              %\item $\mathit{cfgdummy}$ is a fresh symbol of sort $\mathit{Cfg}$;
              \item $\mathit{cfgitem}$ a fresh symbol of sort $\mathit{Cfg} \to \mathit{Cfg}^*$;
              \item $\mathit{cfgnil}$ a fresh symbol of sort $\mathit{Cfg}^*$;
              \item $\mathit{cfgconcat}$ a fresh symbol of sort $\mathit{Cfg}^* \times \mathit{Cfg}^* \to \mathit{Cfg}^*$; and
              \item $\mathit{cfgheat}$ is a fresh symbol of sort $\mathit{Cfg}^* \times \mathit{Cfg} \times \mathit{Cfg}^* \to \mathit{Cfg}^*$.
          \end{enumerate}
    \item Let $S$ be a set of reachability rules over $(\mathbf{\Sigma}, \mathit{Cfg})$.
          We generate a set of reachability rules $S^*$ over $(\mathbf{\Sigma}, \mathit{Cfg})^*$
          by
          \begin{enumerate}
              \item defining a function $\mathit{heat} : \mathit{Var} \times \Pattern \times \mathit{Var} \to \Pattern$ by
              \begin{align*}
                  \mathit{heat}(L, \exists \vec{X}.\, \bigvee_{i=1}^{m} (\phi_i \land P_i), R)
                  = \exists \vec{X}.\, \bigvee_{i=1}^{m} ( \mathit{cfgheat(L, \phi_i, R)} \land P_i)
              \end{align*}
              \item setting
              \begin{align*}
              S^* = \{ \mathit{heat}(L, \varphi, R) \Rightarrow^\exists \mathit{heat}(L, \varphi^\prime, R)
              \mid  ( \varphi \Rightarrow^\exists \varphi^\prime ) \in S \} \, ,
            \end{align*}
                          where $L,R$ are distinct fresh variables (not occurring in any rule in $S$).
          \end{enumerate}
    \item Let $(\Sigma, \mathit{Var})$ be a matching logic signature, and let $\mathcal{T}$ be a configuration model; that is, a $\Sigma$-algebra.
          We generate a $\Sigma^*$-algebra $\mathcal{T}*$, which interprets all sorts and symbols from
          $\Sigma$ as in $\mathcal{T}$, and in addition interprets
          \begin{enumerate}
              \item the sort $\mathit{Cfg}*$ as the set of all finite lists
              $[c_1;\ldots;c_n]$ for $n \in \mathbb{N}$, where $c_i$ is an element of sort $\mathit{Cfg}$
              for any $0 \leq i \leq n$;
              \item the symbol $\mathit{cfgitem}$ as the function $\lambda c.\, [c]$;
              \item the symbol $\mathit{cfgnil}$ as the empty list ($[]$);
              \item the symbol $\mathit{cfgconcat}$ as the function $\lambda l_1,l_2.\, l_1 \texttt{++} l_2$,
                where $\texttt{++}$ is list concatenation; and
              \item the symbol $\mathit{cfgheat}$ as the function
                $\lambda l_1, c, l_2.\, l_1 \texttt{++} [c] \texttt{++} l_2$.
          \end{enumerate}

    \item Let $(\Sigma, \mathit{Var})$ be a matching logic signature, let $\mathcal{T}$ be a configuration model,
        and let $\rho$ be a $\mathcal{T}$-valuation.
        We define a $\mathcal{T}^*$-valuation $\rho^*$ by letting $\rho^*(v) = \rho(v)$ for any $v \in \mathit{Var}$.
          
    \item Let $\mathcal{S} = (\mathcal{T}, S)$ be a reachability system over $(\Sigma, \mathit{Cfg})$.
          We generate a reachability system $\mathcal{S}^*$ over $(\Sigma, \mathit{Cfg})^*$
          by setting $\mathcal{S}^* = (\mathcal{T}^*, S^*)$.
\end{enumerate}
\end{definition}

\begin{lemma}\label{lem:rhoStarOfPi}
    Let $(\Sigma, \mathit{Var})$ be a matching logic signature, $\mathcal{T}$ be a configuration model,
    and $\rho$ be a $\mathcal{T}$-valuation. Then for any basic $(\Sigma, \mathit{Var})$-pattern $\pi$,
    \begin{equation}
        \rho^*(\pi) = \rho(\pi) \, .
    \end{equation}
\end{lemma}
\begin{proof}
    By induction on the term $\pi$.
    \begin{itemize}
        \item $\pi = v$ for $v \in \mathit{Var}$ - follows from the definition of $\rho^*$.
        \item $\pi = f(\pi_1, \ldots, \pi_k)$ - we have $\rho(\pi_i) = \rho^*(\pi_i)$ for any $i \in \{ 1, \ldots, k \}$
              by the induction hypothesis.
              Then
              \begin{align*}
                  \rho^*(f(\pi_1, \ldots, \pi_k)) 
                  = & {\mathcal{T}^*}_f(\rho^*(\pi_1), \ldots, \rho^*(\pi_k)) \\
                  = & {\mathcal{T}^*}_f(\rho(\pi_1), \ldots, \rho(\pi_k)) \\
                  = & \mathcal{T}_f(\rho(\pi_1), \ldots, \rho(\pi_k)) \\
                  = & \rho(f(\pi_1, \ldots, \pi_k))
              \end{align*}
              where the second-to-last equality holds by definition of $\mathcal{T}^*$.
    \end{itemize}
\end{proof}

\begin{lemma}\label{lem:starConservative}
    The star extension on matching logic models is conservative, in the following sense.
    For any $\Sigma$-model $\mathcal{T}$, any $\mathcal{T}$-valuation $\rho$,
    any $\Sigma$-sort $s$,
    any $\gamma \in \mathcal{T}_s$,
    and any matching logic $s$-pattern $\varphi$,
    \begin{equation*}
        (\mathcal{T}, \gamma, \rho) \vDash \varphi \iff (\mathcal{T}^*, \gamma, \rho^*) \vDash \varphi
    \end{equation*}
\end{lemma}
\begin{proof}
By induction on $\varphi$.
\begin{itemize}
    \item $\varphi \equiv \pi$, where $\pi$ is a basic pattern (of sort $s$) - follows from \Cref{lem:rhoStarOfPi}.
    \item $\varphi \equiv \varphi_1 \land \varphi_2$ - follows from the induction hypothesis.
    \item $\varphi \equiv \neg \varphi^\prime$ - follows from the induction hypothesis.
    \item $\varphi \equiv \exists x : s^\prime.\, \varphi^\prime$. We have
    $ (\mathcal{T}^*, \gamma, \rho^\prime) \vDash \exists x : s^\prime.\, \varphi^\prime $
    if and only if (by definition of $\vDash$)
    there exists some valuation ${\rho^*}^\prime : \mathit{Var} \to \mathcal{T}^*$ such that
    $(\mathcal{T}^*, \gamma, {\rho^*}^\prime) \vDash \varphi^\prime$
    and ${\rho^*}^\prime(x) \in \mathcal{T}^*_{s^\prime}$\traian{you need to use $s'$ here and in the following.}
    and ${\rho^*}^\prime(y) = \rho^*(y)$ for all $y \in \mathit{Var} \setminus \{ x \}$.
    This holds if and only if
    there exists some valuation $\rho^{\prime} : \mathit{Var} \to \mathcal{T}$ such that
    $(\mathcal{T}^*, \gamma, {\rho^{\prime}}^*) \vDash \varphi^\prime$
    and ${\rho^{\prime}}^*(x) \in \mathcal{T}^*_s$
    and ${\rho^{\prime}}^*(y) = \rho^*(y)$ for all $y \in \mathit{Var} \setminus \{ x \}$:
    one implication follows by letting ${\rho^*}^\prime := \rho^{\prime}$;
    for the other implication, we let $\rho^{\prime}(v) := {\rho^*}^\prime(v)$ for all $v \in \mathit{Var}$,
    and by the definition of star, we have ${\rho^{\prime}}^*(v) = {\rho^*}^\prime(v)$, from which the rest follows.
    Next, by the induction hypothesis, this holds if and only if
    there exists some valuation $\rho^{\prime} : \mathit{Var} \to \mathcal{T}$ such that
    $(\mathcal{T}, \gamma, {\rho^{\prime}}) \vDash \varphi^\prime$
    and ${\rho^{\prime}}^*(x) \in \mathcal{T}^*_s$
    and ${\rho^{\prime}}^*(y) = \rho^*(y)$ for all $y \in \mathit{Var} \setminus \{ x \}$.
    Next, by the definition of ${\rho^\prime}^*$ and $\rho^*$, this holds if and only if
    there exists some valuation $\rho^{\prime} : \mathit{Var} \to \mathcal{T}$ such that
    $(\mathcal{T}, \gamma, {\rho^{\prime}}) \vDash \varphi^\prime$
    and ${\rho^{\prime}}(x) \in \mathcal{T}^*_s$
    and ${\rho^{\prime}}(y) = \rho(y)$ for all $y \in \mathit{Var} \setminus \{ x \}$.
    But since the star extensions interprets all sorts from $\Sigma$ as in the original model
    (that is, $\mathcal{T}^*_s = \mathcal{T}_s$),
    this is equivalent to the semantics of $(\mathcal{T}, \gamma, \rho) \vDash \exists x:s^\prime.\, \varphi^\prime$,
    which is what we wanted to prove.

    Alternate attempt:
    The induction hypothesis is: for any $\mathcal{T}$, $\gamma$, $\rho$, 
        $$(\mathcal{T}, \gamma, \rho) \vDash \varphi' \iff (\mathcal{T}^*, \gamma, \rho^\ast) \vDash \varphi'$$
    We want to prove that for any $\mathcal{T}$, $\gamma$, $\rho$, 
        $$(\mathcal{T}, \gamma, \rho) \vDash \exists x:s'. \varphi' \iff (\mathcal{T}^*, \gamma, \rho^\ast) \vDash \exists x:s'.\varphi'$$
    
    First, let us prove the left-to-right implication.
    The left-hand-side of the claim is equivalent with
    $$\exists \rho'. (\forall y. y \neq x \to \rho'(y) = \rho(y)) \wedge (T, \gamma, \rho') \vDash \varphi'$$
    From the induction hypothesis, this is further equivalent with
    $$\exists \rho'. (\forall y. y \neq x \to \rho'(y) = \rho(y)) \wedge (T^\ast, \gamma, {\rho'}^\ast) \vDash \varphi'$$
    
    Since $\forall y. y \neq x \to {\rho'}^\ast(y) = \rho'(y) = \rho(y) = \rho^\ast(y)$, we deduce $(\mathcal{T}^*, \gamma, \rho^\ast) \vDash \exists x:s'.\varphi'$.
    
    Conversely, the right-hand-side of the claim is equivalent with
    $$\exists \rho''. (\forall y. y \neq x \to \rho'(y) = \rho\ast(y)) \wedge (T^\ast, \gamma, \rho'') \vDash \varphi'$$
    Let $\rho'$ be defined by $\rho'(y) = \rho(y)$ if $y\neq x$ and $\rho'(x) = \rho''(x)$. Then it is
    easy to see that ${\rho'}^\ast = \rho''$, whence by the induction hypothesis we obtain that
    $(T, \gamma, \rho') \vDash \varphi'$, and by the definition of $\rho'$, $(T, \gamma, \rho) \vDash \exists x:s'. \varphi'$.
 \end{itemize}
\end{proof}

\begin{lemma}\label{lem:compositeStep}
    Let $\mathcal{S} = (\mathcal{T}, S)$ be a reachability-logic system over $(\Sigma, \mathit{Cfg})$.
    For any $k \geq 1$, any configurations $c_1,\ldots,c_k, c^\prime \in \Tcfg$, and any $1 \leq i \leq k$,
    we have
    \begin{equation*}
        c_i \Rightarrow_{\mathcal{S}} c^\prime
                    \iff
        [c_1,\ldots,c_k] \Rightarrow_{\mathcal{S}^*} [c_1, \ldots, c_{i-1}, c^\prime, c_{i+1}, \ldots, c_k]
    \end{equation*}
\end{lemma}
\begin{proof}
Admitted.
\end{proof}


\section{Proof System}

The proof system derives claims of the shape
$\mathcal{S}, \vdash_\CRL \Phi \Downarrow_{C,E} \Psi$,
where $\Phi$,$\Psi$ are of the shape
$\exists \vec{X}.\, (\varphi_1, \ldots, \varphi_k) \land P$,
where $P$ is a structureless FOL formula
and every $\varphi_i$ has the structure of
$\exists x_1,\ldots,x_n. (\phi_1 \land P_1) \lor \ldots (\phi_m \land P_m)$.
The idea is that $P$ is the part of the claim that relates variables from different components.
Initially, the proof starts with the claim
$\mathcal{S} \vdash_\CRL \Phi \Downarrow_{\emptyset, \emptyset} \Psi$.

\begin{definition}
We define $\mathit{mergePatterns}$ and $\mathit{flatten}$ as follows:
\begin{enumerate}
    \item
    \begin{align*}
     & \mathit{mergePatterns}(\exists \vec{X_1}.\, \bigvee_{i_{1}=1}^{m_1} (\phi_{i_1} \land P_{i_1}),
     \ldots, \exists \vec{X_n}.\, \bigvee_{i_{n}=1}^{m_n} (\phi_{i_n} \land P_{i_n}))
     \\ & = \exists \vec{X_1}\ldots\vec{X_n}.\, \bigvee_{i_{1}=1}^{m_1} \ldots \bigvee_{i_{n}=1}^{m_n}
       (\mathit{mkList}(\phi_{1, i_1}, \ldots, \phi_{n, i_n}) \land (P_{1, i_1} \land \ldots \land P_{n, i_n}))
    \end{align*}
    \item
        \begin{align*}
            & \mathit{constrain}(P, \exists \vec{X^\prime} .\,
            \bigvee_{i=1}^{m} (\phi^\prime_i \land P^\prime_i))
            \\& = (\exists \vec{X^\prime}.\, (\phi^\prime_i \land (P^\prime_i \land P))
    \end{align*}
    (we assume that $\alpha$-renaming of (free) variables of $P$ happens implicitly);
    \item
        \begin{align*}
            & \mathit{flatten}(\exists \vec{X}.\, (\varphi_1, \ldots, \varphi_k) \land P)
            = \exists \vec{X}.\, \mathit{constrain}(P, \mathit{mergePatterns}(\varphi_1, \ldots, \varphi_k))
    \end{align*}
    \item $\mathit{flatten}^\exists(\Psi, \Psi^\prime) = \mathit{flatten}(\Psi) \Rightarrow^\exists \mathit{flatten}(\Psi^\prime)$
    \item $\mathit{flatten}^\exists(A, \Psi^\prime) = \{ \mathit{flatten}^\exists(\Psi, \Psi^\prime) \mid \Psi \in A \}$, where $A$ is a set.
\end{enumerate}
\end{definition}

\begin{lemma}\label{lem:constrain}
  For any structureless pattens $P, Q, P_1, \ldots, P_m$
  and any basic patterns $\phi_1, \ldots, \phi_m$,
    \begin{align*}
        \vDash_\ML & \mathit{constrain}(P \lor Q, \exists x_1,\ldots,x_{n}.\, (\phi_1 \land P_1) \lor \ldots (\phi_m \land P_{m})) \leftrightarrow
        \\ & ( \mathit{constrain}(P, \exists x_1,\ldots,x_{n}.\, (\phi_1 \land P_1) \lor \ldots (\phi_m \land P_{m}))
        \\ & \ \mathit{constrain}(Q, \exists x_1,\ldots,x_{n}.\, (\phi_1 \land P_1) \lor \ldots (\phi_m \land P_{m})) ) \, .
    \end{align*}
\end{lemma}
\begin{proof}
Admitted.
\end{proof}

\begin{lemma}\label{lem:doubleconstrain}
    \begin{align*}
        \vDash_\ML & \mathit{constrain}(P , \mathit{constrain}(Q, \varphi))
        \leftrightarrow \mathit{constrain}(P \land Q, \varphi)
    \end{align*}
\end{lemma}
\begin{proof}
Admitted.
\end{proof}

\begin{lemma}\label{lem:constrainMergeComm}
    \begin{align*}
        \vDash_\ML & \mathit{mergePatterns}(\varphi_1, \ldots, \varphi_{i-1}, \mathit{constrain}(P, \varphi_i), \varphi_{i+1}, \ldots, \varphi_k) \\
        & \leftrightarrow \mathit{constrain}(P, \mathit{mergePatterns(\varphi_1, \ldots, \varphi_k)})
    \end{align*}
\end{lemma}

\begin{lemma}\label{lem:constrainAsConjunction}
    \begin{align*}
        \vDash_{\ML} & \mathit{constrain}(P, \varphi) \leftrightarrow \varphi \land P
    \end{align*}
\end{lemma}

\begin{figure}
    \centering
    \begin{align*}
    & \prftree[l]{Reflexivity}{\mathcal{S} \vdash_\CRL \Psi \Downarrow_{\emptyset,E} \Psi}
    \end{align*}
    \begin{align*}
    & \prftree[l]{Axiom}{\Psi \in E}{\mathcal{S} \vdash_\CRL \Psi \Downarrow_{C,E} \Psi^\prime}
    \end{align*}
    \begin{align*}
    & \prftree[l]{Reduce}
      {(\mathcal{T}^*, S^* \cup \mathit{flatten}^\exists(E, \Psi^\prime)), \emptyset \vdash_\RL
        \mathit{flatten}^\exists(\Psi, \Psi^\prime) }
      {(\mathcal{T}, S) \vdash_\CRL \Psi \Downarrow_{C,E} \Psi^\prime}
    \end{align*}
    \begin{align*}
    & \prftree[l]{Case}
    { \prfStackPremises
      {\mathcal{S} \vdash_\CRL (\varphi_1, \ldots, \varphi_{i-1}, \varphi_i, \varphi_{i+1}, \ldots, \varphi_k) \land P^\prime \Downarrow_{C, E} \Psi^\prime }
      {\mathcal{S} \vdash_\CRL (\varphi_1, \ldots, \varphi_{i-1}, \psi_i, \varphi_{i+1}, \ldots, \varphi_k) \land P^\prime \Downarrow_{C, E} \Psi^\prime }
    }
    {\mathcal{S} \vdash_\CRL (\varphi_1, \ldots, \varphi_{i-1}, (\varphi_i \lor \psi_i), \varphi_{i+1}, \ldots, \varphi_k) \land P^\prime \Downarrow_{C, E} \Psi^\prime}
    \end{align*}
    \begin{align*}
    & \prftree[l]{Step}
    { \prfStackPremises
       {\varphi \Rightarrow^\exists \varphi^\prime \in S}
       {\mathcal{T} \vDash_\ML \varphi_i \leftrightarrow \mathit{constrain}(P^\prime, \varphi)}
       {P^\prime \mbox{ is a structureless FOL formula}}
       {  (\mathcal{T}, S) \vdash_\CRL (\varphi_1, \ldots, \varphi_{i-1}, \mathit{constrain}(P^\prime, \varphi^\prime), \varphi_{i+1}, \ldots, \varphi_k)
          \land P
          \Downarrow_{\emptyset, (C \cup E)} \Psi^\prime
      }
    }
    {(\mathcal{T}, S) \vdash_\CRL (\varphi_1, \ldots, \varphi_{i-1}, \varphi_i, \varphi_{i+1}, \ldots, \varphi_k) \land P \Downarrow_{C, E} \Psi^\prime}
    \end{align*}
    \begin{align*}
    & \prftree[l]{Circularity}
      { \mathcal{S} \vdash_\CRL \Psi \Downarrow_{C \cup \{ \Psi \} , E} \Psi^\prime}
      { \mathcal{S} \vdash_\CRL \Psi \Downarrow_{C, E} \Psi^\prime}
    \end{align*}
    \begin{align*}
    & \prftree[l]{Conseq}
      { \prfStackPremises
        { (\mathcal{T}, S) \vdash_\CRL \Phi^\prime \Downarrow_{C, E} \Psi^\prime}
        { \mathcal{T}^* \vDash_\ML \mathit{flatten}(\Phi) \rightarrow \mathit{flatten}(\Phi^\prime) }
      }
      { (\mathcal{T}, S) \vdash_\CRL \Phi \Downarrow_{C, E} \Psi^\prime}
    \end{align*}
%    \begin{align*}
%    & \prftree[l]{Conseq2}
%      { \prfStackPremises
%        { (\mathcal{T}, S) \vdash_\CRL (\varphi_1, \ldots, \varphi_k) \land P \Downarrow_{C, E} \Psi^\prime}
%        { \mathcal{T} \vDash_\ML \varphi_i \leftrightarrow \psi_i }
%      }
%      { (\mathcal{T}, S) \vdash_\CRL (\varphi_1^\prime, \ldots, \varphi_{i-1}, \varphi_{i}, \varphi_{i+1}, \ldots, \varphi_k^\prime) \land P^\prime \Downarrow_{C, E} \Psi^\prime}
%    \end{align*}

    %\begin{align*}
    %& \prftree[l]{Abstract}
      %{ \prfStackPremises
        %{ X \not\in \mathit{FV}(\Psi^\prime, \varphi_1, \ldots, \varphi_{i-1}, \varphi_{i+1}, \ldots,\varphi_k)
        %}
        %{(\mathcal{T}, S) \vdash_\CRL (\varphi_1, \ldots, \varphi_{i-1}, \varphi_i, \varphi_{i+1}, \ldots, \varphi_k) \land P \Downarrow_{C, E} \Psi^\prime}
      %}
      %{(\mathcal{T}, S) \vdash_\CRL (\varphi_1, \ldots, \varphi_{i-1}, \exists X.\, \varphi_i, \varphi_{i+1}, \ldots, \varphi_k) \land P \Downarrow_{C, E} \Psi^\prime}
    %\end{align*}
    
    \begin{align*}
    & \prftree[l]{Abstract}
      { \prfStackPremises
        { X \not\in \mathit{FV}(\Psi^\prime)
        }
        {(\mathcal{T}, S) \vdash_\CRL \exists \vec{Y}.\, (\varphi_1, \ldots, \varphi_k) \land P \Downarrow_{C, E} \Psi^\prime}
      }
      {(\mathcal{T}, S) \vdash_\CRL \exists X, \vec{Y}.\, (\varphi_1, \ldots, \varphi_k) \land P \Downarrow_{C, E} \Psi^\prime}
    \end{align*}
    \caption{Proof System}
    \label{fig:my_label}
\end{figure}



\begin{lemma}
    \begin{align*}
        & (\mathcal{T}, S) \vdash_\CRL \Psi \Downarrow_{C,E} \Psi^\prime \implies \\
        &
        (\mathcal{T}^*, S^* \cup \mathit{flatten}^\exists(E, \Psi^\prime)), \mathit{flatten}^\exists(C, \Psi^\prime) \vdash_\RL
          \mathit{flatten}^\exists(\Psi, \Psi^\prime) 
    \end{align*}
\end{lemma}
\begin{proof}
By induction on the structure of the CRL proof. TODO
\begin{enumerate}
    \item If the proof ends with \emph{Reduce}, then we are done, since $\mathit{flatten}^\exists(\emptyset, \psi^\prime) = \emptyset$.
    
    \item If the proof ends with \emph{Reflexivity}, then we need to prove
    \begin{equation*}
        \mathcal{S}^*, \mathit{flatten}^\exists(E, \psi), \emptyset \vdash_\RL
          \mathit{flatten}^\exists(\psi, \psi) 
    \end{equation*}
    which we do by applying the Reflexivity proof rule.
    
    \item If the proof ends with \emph{Axiom}, then $\psi \in E$,
          and we have to prove that
          \begin{equation*}
            \mathcal{S}^*, \mathit{flatten}^\prime(E, \psi^\prime), \mathit{flatten}^\prime(C, \psi^\prime) \vdash_\RL
            \mathit{flatten}^\prime(\psi, \psi^\prime)               \, .
          \end{equation*}
          By applying the Axiom proof rule of RL, it is enough to show that
          \begin{equation*}
              \mathit{flatten}^\prime(\psi, \psi^\prime) \in \mathit{flatten^\prime}(E, \psi^\prime) \, ,
          \end{equation*}
          which follows from $\psi \in E$.
          
    \item If the proof ends with \emph{Case}, then we have
        \begin{equation*}
            \mathcal{S}^*, \Bar{E}, \Bar{C} \vdash_\RL
            \mathit{flatten}^\exists((\varphi_1, \ldots, \varphi_{i-1}, \varphi_i, \varphi_{i+1}, \ldots, \varphi_k) \land P^\prime, \Psi^\prime)
        \end{equation*}
        and
        \begin{equation*}
            \mathcal{S}^*, \Bar{E}, \Bar{C} \vdash_\RL
            \mathit{flatten}^\exists((\varphi_1, \ldots, \varphi_{i-1}, \psi_i, \varphi_{i+1}, \ldots, \varphi_k) \land P^\prime, \Psi^\prime) 
        \end{equation*}
        as hypotheses, and we have to prove
        \begin{equation*}
            \mathcal{S}^*, \Bar{E}, \Bar{C} \vdash_\RL
            \mathit{flatten}^\exists((\varphi_1, \ldots, \varphi_{i-1}, (\varphi_i \lor \psi_i), \varphi_{i+1}, \ldots, \varphi_k) \land P^\prime, \Psi^\prime)               \, .
        \end{equation*}
        (where $\Bar{E} = \mathit{flatten}^\exists(E, \psi^\prime)$
         and $\Bar{C} = \mathit{flatten}^\exists(C, \psi^\prime)$
        ).
        After simplifications, we get
        \begin{align*}
            \mathcal{S}^*, \Bar{E}, \Bar{C} \vdash_\RL
            &
            \mathit{constrain}(P^\prime, \mathit{mergePatterns}((\varphi_1, \ldots, \varphi_{i-1}, \varphi_i, \varphi_{i+1}, \ldots, \varphi_k)))
            \\ & \Rightarrow^\exists
            \mathit{flatten}(\Psi^\prime)
        \end{align*}
        and
        \begin{align*}
            \mathcal{S}^*, \Bar{E}, \Bar{C} \vdash_\RL
            &
            \mathit{constrain}(P^\prime, \mathit{mergePatterns}((\varphi_1, \ldots, \varphi_{i-1}, \psi_i, \varphi_{i+1}, \ldots, \varphi_k)))
            \\ & \Rightarrow^\exists
            \mathit{flatten}(\Psi^\prime)
        \end{align*}
        as hypotheses,
        and have to prove
        \begin{align*}
            \mathcal{S}^*, \Bar{E}, \Bar{C} \vdash_\RL
            &
            \mathit{constrain}(P^\prime, \mathit{mergePatterns}((\varphi_1, \ldots, \varphi_{i-1}, (\varphi_i \lor \psi_i), \varphi_{i+1}, \ldots, \varphi_k)))
            \\ & \Rightarrow^\exists
            \mathit{flatten}(\Psi^\prime)
        \end{align*}
        Since
        \begin{align*}
            \mathcal{T}^* \vDash_\ML & \mathit{constrain}(P^\prime, \mathit{mergePatterns}((\varphi_1, \ldots, \varphi_{i-1}, (\varphi_i \lor \psi_i), \varphi_{i+1}, \ldots, \varphi_k))) \leftrightarrow \\
            & (\mathit{constrain}(P^\prime, \mathit{mergePatterns}((\varphi_1, \ldots, \varphi_{i-1}, \varphi_i, \varphi_{i+1}, \ldots, \varphi_k))) \\
            & \lor \mathit{constrain}(P^\prime, \mathit{mergePatterns}((\varphi_1, \ldots, \varphi_{i-1}, \psi_i, \varphi_{i+1}, \ldots, \varphi_k))))
        \end{align*}
        (where $\mathcal{S}^* = (\mathcal{T}^*, S)$),
        we can apply the Consequence RL rule on the goal, followed by a Case Analysis rule applied to the two hypotheses, and we are done.
        
    \item If the proof ends with \emph{Step},
      we can assume a structureless FOL formula $P^\prime$, a rule $\varphi \Rightarrow^\exists \varphi^\prime \in S$ such that
      $\mathcal{T} \vDash_\ML \varphi_i \leftrightarrow \mathit{constrain}(P^\prime, \varphi)$,
      and an induction hypothesis
      \begin{align*}
        (&\mathcal{T}^*, S^* \cup \mathit{flatten}^\exists(C \cup E, \Psi^\prime)), \emptyset \vdash_\RL
          \\ &
          \mathit{flatten}((\varphi_1, \ldots, \varphi_{i-1}, \mathit{constrain}(P^\prime, \varphi^\prime), \varphi_{i+1}, \ldots, \varphi_k) \land P) \Rightarrow^\exists \mathit{flatten}(\Psi^\prime)     
      \end{align*}
      and have to construct
      \begin{align*}
      & (\mathcal{T}^*, S^* \cup \mathit{flatten}^\exists(E, \Psi^\prime)), \mathit{flatten}^\exists(C, \Psi^\prime) \vdash_\RL \\
          & \mathit{flatten}((\varphi_1, \ldots, \varphi_{i-1}, \varphi_i, \varphi_{i+1}, \ldots, \varphi_k) \land P) \Rightarrow^\exists \mathit{flatten}(\Psi^\prime)    \, .
      \end{align*}
        By definition of $S^*$, we also have
        \begin{align*}
            (\mathit{heat}(L, \varphi, R) \Rightarrow^\exists \mathit{heat}(L, \varphi^\prime, R)) \in S^* \, .
        \end{align*}
      
    We apply the Transitivity rule with the second premise being our first inductive hypothesis, and it remains to prove the second premise, which is (after simplification)
    \begin{align*}
        & (\mathcal{T}, S)^*, \mathit{flatten}^\exists(E, \psi^\prime), \mathit{flatten}^\exists(C, \psi^\prime)
        \\& \vdash_\RL
        \mathit{constrain}(P, \mathit{mergePatterns}(\varphi_1, \ldots, \varphi_{i-1}, \varphi_i, \varphi_{i+1}, \ldots,                          \varphi_k))
        \\&\quad \Rightarrow^\exists
        \mathit{constrain}(P, \mathit{mergePatterns}(\varphi_1, \ldots, \varphi_{i-1}, \mathit{constrain}(P^\prime, \varphi^\prime), \varphi_{i+1}, \ldots, \varphi_k) ) \, .
    \end{align*}
    By Congruence lemma and our assumption $\mathcal{T} \vDash_\ML \varphi_i \leftrightarrow (\varphi \land \psi)$ (adding the star does not break anything, by conservativeness), we have
    \begin{align*}
        \mathcal{T}^* \vDash_\ML &
        \mathit{constrain}(P, \mathit{mergePatterns}(\varphi_1, \ldots, \varphi_{i-1}, \varphi_i, \varphi_{i+1}, \ldots,                          \varphi_k))
        \\ & \leftrightarrow
        \mathit{constrain}(P, \mathit{mergePatterns}(\varphi_1, \ldots, \varphi_{i-1}, \mathit{constrain}(P^\prime, \varphi), \varphi_{i+1}, \ldots, \varphi_k)) \, ,
    \end{align*}
    and therefore we can apply the Consequence rule on the goal, changing it into
    \begin{align*}
        & (\mathcal{T}, S)^*, \mathit{flatten}^\prime(E, \psi^\prime), \mathit{flatten}^\prime(C, \psi^\prime)
        \\& \vdash_\RL
        \mathit{constrain}(P, \mathit{mergePatterns}(\varphi_1, \ldots, \varphi_{i-1}, \mathit{constrain}(P^\prime, \varphi), \varphi_{i+1}, \ldots,                          \varphi_k))
        \\&\quad \Rightarrow^\exists
        \mathit{constrain}(P, \mathit{mergePatterns}(\varphi_1, \ldots, \varphi_{i-1}, \mathit{constrain}(P^\prime, \varphi^\prime), \varphi_{i+1}, \ldots, \varphi_k)) \, .
    \end{align*}
    Now we apply Consequence again using \Cref{lem:constrainMergeComm},
    changing the goal into
    \begin{align*}
        & (\mathcal{T}, S)^*, \mathit{flatten}^\prime(E, \psi^\prime), \mathit{flatten}^\prime(C, \psi^\prime)
        \\& \vdash_\RL
        \mathit{constrain}(P, \mathit{constrain}(P^\prime, \mathit{mergePatterns}(\varphi_1, \ldots, \varphi_{i-1}, \varphi, \varphi_{i+1}, \ldots, \varphi_k)))
        \\&\quad \Rightarrow^\exists
        \mathit{constrain}(P, \mathit{constrain}(P^\prime, \mathit{mergePatterns}(\varphi_1, \ldots, \varphi_{i-1}, \varphi^\prime, \varphi_{i+1}, \ldots, \varphi_k))) \, .
    \end{align*}
    Now apply Consequence again using \Cref{lem:doubleconstrain},
    changing the goal into
    \begin{align*}
        & (\mathcal{T}, S)^*, \mathit{flatten}^\prime(E, \psi^\prime), \mathit{flatten}^\prime(C, \psi^\prime)
        \\& \vdash_\RL
        \mathit{constrain}(P \land P^\prime, \mathit{mergePatterns}(\varphi_1, \ldots, \varphi_{i-1}, \varphi, \varphi_{i+1}, \ldots, \varphi_k))
        \\&\quad \Rightarrow^\exists
        \mathit{constrain}(P \land P^\prime, \mathit{mergePatterns}(\varphi_1, \ldots, \varphi_{i-1}, \varphi^\prime, \varphi_{i+1}, \ldots, \varphi_k)) \, ,
    \end{align*}
    and once again using \Cref{lem:constrainAsConjunction}, changing the goal into
    \begin{align*}
        & (\mathcal{T}, S)^*, \mathit{flatten}^\prime(E, \psi^\prime), \mathit{flatten}^\prime(C, \psi^\prime)
        \\& \vdash_\RL
        \mathit{mergePatterns}(\varphi_1, \ldots, \varphi_{i-1}, \varphi, \varphi_{i+1}, \ldots, \varphi_k)
        \land (P \land P^\prime)
        \\&\quad \Rightarrow^\exists
        \mathit{mergePatterns}(\varphi_1, \ldots, \varphi_{i-1}, \varphi^\prime, \varphi_{i+1}, \ldots, \varphi_k) \land (P \land P^\prime) \, ,
    \end{align*}
    Now we strip $P \land P^\prime$ by applying Logic Framing, resulting in the goal
    \begin{align*}
        & (\mathcal{T}, S)^*, \mathit{flatten}^\prime(E, \psi^\prime), \mathit{flatten}^\prime(C, \psi^\prime)
        \\& \vdash_\RL
        \mathit{mergePatterns}(\varphi_1, \ldots, \varphi_{i-1}, \varphi, \varphi_{i+1}, \ldots, \varphi_k)
        \\&\quad \Rightarrow^\exists
        \mathit{mergePatterns}(\varphi_1, \ldots, \varphi_{i-1}, \varphi^\prime, \varphi_{i+1}, \ldots, \varphi_k) \, .
    \end{align*}
    We apply Consequence again, changing the goal to
    \begin{align*}
        & (\mathcal{T}, S)^*, \mathit{flatten}^\prime(E, \psi^\prime), \mathit{flatten}^\prime(C, \psi^\prime)
        \\ \vdash_\RL &
        \bigvee_{i_1=1}^{m_1} \ldots \bigvee_{i_{j-1}=1}^{m_{j-1}}
        \bigvee_{i_{j+1}=1}^{m_{j+1}} \ldots \bigvee_{i_n=1}^{m_n}
        \exists \vec{X_1} \ldots \vec{X_{j-1}} \vec{X_{j+1}} \ldots \vec{X_n}
        \\& \exists \vec{X_j} \bigvee_{i_j=1}^{m_j} (\mathit{cfgheat}(L, \phi_{j, i_j}, R) \land P_{j, i_j}
        \\&\quad \land (L = \mathit{mkList}(\phi_{1, i_1}, \ldots, \phi_{j-1, i_{j-1}}))
        \\&\quad \land R = \mathit{mkList}(\phi_{j+1, i_{j+1}}, \ldots, \phi_{n, i_{n}})
        \\&\quad \land (P_{1, i_1} \land \ldots \land P_{j-1, i_{j-1}} \land P_{j+1, i_{j+1}} \land \ldots \land P_{n, i_n}))
        \\ \Rightarrow^\exists &
        \bigvee_{i_1=1}^{m_1} \ldots \bigvee_{i_{j-1}=1}^{m_{j-1}}
        \bigvee_{i_{j+1}=1}^{m_{j+1}} \ldots \bigvee_{i_n=1}^{m_n}
        \exists \vec{X_1} \ldots \vec{X_{j-1}} \vec{X_{j+1}} \ldots \vec{X_n}
        \\& \exists \vec{X^\prime_j} \bigvee_{i^\prime_j=1}^{m^\prime_j} (\mathit{cfgheat}(L, \phi^\prime_{j, i^\prime_j}, R) \land P^\prime_{j, i^\prime_j}
        \\&\quad \land (L = \mathit{mkList}(\phi_{1, i_1}, \ldots, \phi_{j-1, i_{j-1}}))
        \\&\quad \land R = \mathit{mkList}(\phi_{j+1, i_{j+1}}, \ldots, \phi_{n, i_{n}})
        \\&\quad \land (P_{1, i_1} \land \ldots \land P_{j-1, i_{j-1}} \land P_{j+1, i_{j+1}} \land \ldots \land P_{n, i_n}))
    \end{align*}
    where $\exists \vec{X_j}.\, \bigvee_{i_j = 1}^{m_j} (\phi_{i_j} \land P_{i_j}) = \varphi $
    and $\exists \vec{X_j^\prime}.\, \bigvee_{i_j^\prime = 1}^{m_j^\prime} (\phi_{i_j^\prime} \land P_{i_j}^\prime) = \varphi^\prime$.
    Now we iteratively apply Case Analysis, followed by Consequence where on the RHS of $\Rightarrow^\exists$ we select the disjunct corresponding to the LHS.
    We end up with a bunch of goals of the shape
    \begin{align*}
        & (\mathcal{T}, S)^*, \mathit{flatten}^\prime(E, \psi^\prime), \mathit{flatten}^\prime(C, \psi^\prime)
        \\ \vdash_\RL &
        \exists \vec{X_1} \ldots \vec{X_{j-1}} \vec{X_{j+1}} \ldots \vec{X_n}
        \\& \exists \vec{X_j} \bigvee_{i_j=1}^{m_j} (\mathit{cfgheat}(L, \phi_{j, i_j}, R) \land P_{j, i_j}
        \\&\quad \land (L = \mathit{mkList}(\phi_{1, i_1}, \ldots, \phi_{j-1, i_{j-1}}))
        \\&\quad \land R = \mathit{mkList}(\phi_{j+1, i_{j+1}}, \ldots, \phi_{n, i_{n}})
        \\&\quad \land (P_{1, i_1} \land \ldots \land P_{j-1, i_{j-1}} \land P_{j+1, i_{j+1}} \land \ldots \land P_{n, i_n}))
        \\ \Rightarrow^\exists &
        \exists \vec{X_1} \ldots \vec{X_{j-1}} \vec{X_{j+1}} \ldots \vec{X_n}
        \\& \exists \vec{X^\prime_j} \bigvee_{i^\prime_j=1}^{m^\prime_j} (\mathit{cfgheat}(L, \phi^\prime_{j, i^\prime_j}, R) \land P^\prime_{j, i^\prime_j}
        \\&\quad \land (L = \mathit{mkList}(\phi_{1, i_1}, \ldots, \phi_{j-1, i_{j-1}}))
        \\&\quad \land R = \mathit{mkList}(\phi_{j+1, i_{j+1}}, \ldots, \phi_{n, i_{n}})
        \\&\quad \land (P_{1, i_1} \land \ldots \land P_{j-1, i_{j-1}} \land P_{j+1, i_{j+1}} \land \ldots \land P_{n, i_n})) \, .
    \end{align*}
    Now we strip the quantifiers using Abstraction followed by Consequence,
    leading to goals of the shape
    \begin{align*}
        & (\mathcal{T}, S)^*, \mathit{flatten}^\prime(E, \psi^\prime), \mathit{flatten}^\prime(C, \psi^\prime)
        \\ \vdash_\RL &
        \exists \vec{X_j} \bigvee_{i_j=1}^{m_j} (\mathit{cfgheat}(L, \phi_{j, i_j}, R) \land P_{j, i_j}
        \\&\quad \land (L = \mathit{mkList}(\phi_{1, i_1}, \ldots, \phi_{j-1, i_{j-1}}))
        \\&\quad \land R = \mathit{mkList}(\phi_{j+1, i_{j+1}}, \ldots, \phi_{n, i_{n}})
        \\&\quad \land (P_{1, i_1} \land \ldots \land P_{j-1, i_{j-1}} \land P_{j+1, i_{j+1}} \land \ldots \land P_{n, i_n}))
        \\ \Rightarrow^\exists &
        \exists \vec{X^\prime_j} \bigvee_{i^\prime_j=1}^{m^\prime_j} (\mathit{cfgheat}(L, \phi^\prime_{j, i^\prime_j}, R) \land P^\prime_{j, i^\prime_j}
        \\&\quad \land (L = \mathit{mkList}(\phi_{1, i_1}, \ldots, \phi_{j-1, i_{j-1}}))
        \\&\quad \land R = \mathit{mkList}(\phi_{j+1, i_{j+1}}, \ldots, \phi_{n, i_{n}})
        \\&\quad \land (P_{1, i_1} \land \ldots \land P_{j-1, i_{j-1}} \land P_{j+1, i_{j+1}} \land \ldots \land P_{n, i_n})) \, .
    \end{align*}
    Since variables from $\vec{X_j}$ and $\vec{X_j^\prime}$ can occur only in $\phi_{j, i_j}$,
    $\phi^\prime_{j, i_j}$, $P_{j, i_j}$ and $P^\prime_{j, i_j}$, we can change the goals
    (using Consequence) into
    \begin{align*}
        & (\mathcal{T}, S)^*, \mathit{flatten}^\prime(E, \psi^\prime), \mathit{flatten}^\prime(C, \psi^\prime)
        \\ \vdash_\RL &
        (\exists \vec{X_j} \bigvee_{i_j=1}^{m_j} \mathit{cfgheat}(L, \phi_{j, i_j}, R) \land P_{j, i_j})
        \\&\land L = \mathit{mkList}(\phi_{1, i_1}, \ldots, \phi_{j-1, i_{j-1}})
        \\&\land R = \mathit{mkList}(\phi_{j+1, i_{j+1}}, \ldots, \phi_{n, i_{n}})
        \\&\land (P_{1, i_1} \land \ldots \land P_{j-1, i_{j-1}} \land P_{j+1, i_{j+1}} \land \ldots \land P_{n, i_n})
        \\ \Rightarrow^\exists &
        (\exists \vec{X^\prime_j} \bigvee_{i^\prime_j=1}^{m^\prime_j} \mathit{cfgheat}(L, \phi^\prime_{j, i^\prime_j}, R) \land P^\prime_{j, i^\prime_j})
        \\&\land L = \mathit{mkList}(\phi_{1, i_1}, \ldots, \phi_{j-1, i_{j-1}})
        \\&\land R = \mathit{mkList}(\phi_{j+1, i_{j+1}}, \ldots, \phi_{n, i_{n}})
        \\&\land (P_{1, i_1} \land \ldots \land P_{j-1, i_{j-1}} \land P_{j+1, i_{j+1}} \land \ldots \land P_{n, i_n}) \, .
    \end{align*}
    We conclude this case by applying Framing and Axiom.
    
    \item If the proof ends with \emph{Circularity}, we can assume
        \begin{align*}
            (\mathcal{T}^*, S^* \cup \mathit{flatten}^\exists(E, \Psi^\prime)),
            \mathit{flatten}^\exists(C \cup \{ \Psi \}, \Psi^\prime) \vdash_\RL
            \mathit{flatten}^\exists(\Psi, \Psi^\prime)
        \end{align*}
        which simplifies to
        \begin{align*}
            (\mathcal{T}^*, S^* \cup \mathit{flatten}^\exists(E, \Psi^\prime)),
            \mathit{flatten}^\exists(C, \Psi^\prime) \cup \mathit{flatten}^\exists(\{ \Psi \}, \Psi^\prime) \vdash_\RL
            \mathit{flatten}^\exists(\Psi, \Psi^\prime)
        \end{align*}
        and have to prove
        \begin{align*}
            (\mathcal{T}^*, S^* \cup \mathit{flatten}^\exists(E, \Psi^\prime)),
            \mathit{flatten}^\exists(C, \Psi^\prime) \vdash_\RL
            \mathit{flatten}^\exists(\Psi, \Psi^\prime)
        \end{align*}
        which follows from the assumption by Circularity.
        
    \item If the proof ends with \emph{Conseq}, we can assume
    \begin{align*}
        \mathcal{T}^* \vDash_\ML \mathit{flatten}(\Phi) \rightarrow \mathit{flatten}(\Phi^\prime)
    \end{align*}
    and
    \begin{align*}
        (\mathcal{T}^*, S^* \cup \mathit{flatten}^\exists(E, \Psi^\prime)), \mathit{flatten}^\exists(C, \Psi^\prime) \vdash_\RL
          \mathit{flatten}^\exists(\Phi^\prime, \Psi^\prime) \, ,
    \end{align*}
    and have to prove
    \begin{align*}
        (\mathcal{T}^*, S^* \cup \mathit{flatten}^\exists(E, \Psi^\prime)), \mathit{flatten}^\exists(C, \Psi^\prime) \vdash_\RL
          \mathit{flatten}^\exists(\Phi, \Psi^\prime)  \, .
    \end{align*}
    The second assumption simplifies to
    \begin{align*}
        (\mathcal{T}^*, S^* \cup \mathit{flatten}^\exists(E, \Psi^\prime)), \mathit{flatten}^\exists(C, \Psi^\prime) \vdash_\RL
          \mathit{flatten}(\Phi^\prime) \Rightarrow^\exists \mathit{flatten}(\Psi^\prime) \, ,
    \end{align*}
    while the goal to
    \begin{align*}
        (\mathcal{T}^*, S^* \cup \mathit{flatten}^\exists(E, \Psi^\prime)), \mathit{flatten}^\exists(C, \Psi^\prime) \vdash_\RL
          \mathit{flatten}(\Phi) \Rightarrow^\exists \mathit{flatten}(\Psi^\prime) \, ;
    \end{align*}
    therefore, we can apply the \emph{Consequence} rule.        
        
        
    \item If the proof ends with \emph{Abstract},
    we assume
    \begin{align*}
        X \not\in \mathit{FV}(\Psi^\prime)
    \end{align*}
    and
    \begin{align*}
                (\mathcal{T}^*, S^* \cup \mathit{flatten}^\exists(E, \Psi^\prime)), \mathit{flatten}^\exists(C, \Psi^\prime) \vdash_\RL
          \mathit{flatten}^\exists(\exists \vec{Y}.\, (\varphi_1, \ldots, \varphi_k) \land P, \Psi^\prime)
    \end{align*}
    and have to prove that
    \begin{align*}
                (\mathcal{T}^*, S^* \cup \mathit{flatten}^\exists(E, \Psi^\prime)), \mathit{flatten}^\exists(C, \Psi^\prime) \vdash_\RL
          \mathit{flatten}^\exists(\exists X,\vec{Y}.\, (\varphi_1, \ldots, \varphi_k) \land P, \Psi^\prime) \, .
    \end{align*}
    After simplifications, the second premise becomes
    \begin{align*}
            &(\mathcal{T}^*, S^* \cup \mathit{flatten}^\exists(E, \Psi^\prime)), \mathit{flatten}^\exists(C, \Psi^\prime) \vdash_\RL
          \\& \exists \vec{Y}.\, \mathit{constrain}(P, \mathit{mergePatterns}(\varphi_1, \ldots, \varphi_k))
          \Rightarrow^\exists \mathit{flatten}(\Psi^\prime) \, ,
    \end{align*}
    while the goal becomes
    \begin{align*}
          &(\mathcal{T}^*, S^* \cup \mathit{flatten}^\exists(E, \Psi^\prime)), \mathit{flatten}^\exists(C, \Psi^\prime) \vdash_\RL
          \\&\exists X,\vec{Y}.\, \mathit{constrain}(P, \mathit{mergePatterns}(\varphi_1, \ldots, \varphi_k))
          \Rightarrow^\exists \mathit{flatten}(\Psi^\prime) \, .
    \end{align*}
    We prove the goal using the Abstraction rule
    (note that $X \not\in \mathit{FV}(\Psi^\prime)$ implies $X \not\in \mathit{FV}(\mathit{flatten}(\Psi^\prime))$).
    
    \end{enumerate}
\end{proof}

\section{Implementation}

\bibliography{bibliography}
\bibliographystyle{plain}

\appendix


\end{document}
