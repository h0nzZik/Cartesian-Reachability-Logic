\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amssymb,mathtools}
\usepackage{amsthm}
\usepackage{thmtools}
\usepackage{hyperref}
% `cleveref` has to be loaded after `hyperref`
\usepackage{cleveref}
\usepackage{stackengine}
\usepackage{minted}
\usepackage{tcolorbox}
\usepackage{multicol}
\usepackage{prftree}
\usepackage{fancyvrb}
\usepackage{csquotes}
\usepackage{appendix}
\usepackage{enumitem}
\usepackage{todonotes}

\newcommand{\traian}[1]{\todo[author=Traian]{#1}}
\newcommand{\jt}[1]{\todo[author=Jan]{#1}}

\title{Cartesian Reachability Logic: A Language-Independent Logic for Verifying $k$-Safety Properties}
\author{Jan Tu\v{s}il  \and Traian Florin Șerbănuță 
%\and Xiaohong Chen
\and Jan Obdrzalek
}
\date{\today}

\declaretheorem[]{example}
\declaretheorem[]{definition}
\declaretheorem[]{lemma}
\declaretheorem[]{theorem}
\declaretheorem[]{remark}

\newcommand{\K}{$\mathbb{K}$}
\newcommand{\RL}{\mathsf{RL}}
\newcommand{\ML}{\mathsf{ML}}
\newcommand{\CRL}{\mathsf{CRL}}
\newcommand{\FOL}{\mathsf{FOL}}
\newcommand{\FOLeq}{\FOL_{=}}
\newcommand{\Var}{\mathit{Var}}
\newcommand{\Tcfg}{\mathcal{T}_{\mathit{Cfg}}}
\newcommand{\Pattern}{\mathsf{Pattern}}

\newcommand\oast{\stackMath\mathbin{\stackinset{c}{0ex}{c}{0ex}{\ast}{\bigcirc}}}

\newenvironment{proofenv}
  {
    \VerbatimEnvironment\begin{tcolorbox}[colback=black!0!white] % 5 is the default
  }
  {
   \end{tcolorbox}
  }

\begin{document}

\maketitle

\section{Introduction}
Recent years have witnesssed an increased interest in formal verification of \emph{hyperproperties}.
A hyperproperty is a set of \emph{sets of} execution traces, with the following semantics:
a system $S$ (a set of traces) satisfies a hyperproperty $H$ iff $S \in H$.
Hyperproperties are strictly more expressive then properties; for example, many security policies
of interest are hyperproperties but not properties.

Techniques and tools for verifying hyperproperties of (finite-state) hardware \cite{CoenenFST19,FinkbeinerRS15},
as well as (infinite-state) software systems have been developed.
For verification of software systems in particular, \emph{Cartesian Hoare logic} (CHL, \cite{SousaD16}) extends Hoare logic
to reason about \emph{$k$-safety hyperproperties}
(a hyperproperty is a \emph{$k$-safety hyperproperty} if its violation can be witnessed
by a set of traces of size $k$).
However, it is not clear how to use these techniques with arbitrary programming languages,
since CHL is tied to a particular imperative language.

On the other hand, there have been recent developments in the are of \emph{language-independent} software verification.
\emph{Reachability logic} (RL) \cite{RosuS12oopsla,RosuSCM13lics,StefanescuCMMSR19}
is a
formalism for reasoning about partial correctness of software, in the spirit of Hoare logics.
Being implemented in the \K{} framework \cite{KVision},
its biggest advantage is that reachability logic is \emph{language independent}:
its proof system can be used unchanged to reason about programs in any language,
as long as the language has a formal semantics in RL.
Therefore, researchers no longer need to think about a particular language construct three times
(once for the operational semantics, once for axiomatic, and once for the correspondence);
additionally, a single researcher or a tool-builder does not need to understand both the precise (and often intricate)
semantics of a programming language, \emph{and} formal verification techniques,
which makes \emph{division of labour} possible.
Through \K{}, reachability logic has been used to build verifiers for real-world languages,
such as C (\cite{RVMatch}), Java (\cite{StefanescuPYLR16VerifiersForAll}), Javascript (\cite{StefanescuPYLR16VerifiersForAll}),
and EVM (\cite{KevmVerificationTool}).

Can we have the best of both worlds? We think it is possible.
In this paper we develop a logic named \emph{Cartesian Reachability logic (CRL)}, which properly extends reachability logic
to allow reasoning about $k$-safety hyperproperties. Simiarly to CHL, CRL has a sound
and relatively complete proof system. A major advantage of CRL against CHL is that it works with any language
for which RL works; that is, with any language which has a RL-based formal semantics.
However, CRL does \emph{not} extend CHL, because the two logics give different semantics to properties of nondeterministic programs;
despite this distinction, CRL extends CHL on the deterministic fragment of the CHL-supported language.
We elaborate on this relation in \Cref{sec:discussion}. 

The idea behind soundness and completeness of our approach is similar to the one of \cite{SousaD16} for CHL.
We define a language-agnostic equivalent of self-composition (\cite{BartheDR11}) and establish a relation
between CRL validity of the original and RL validity of the composed system.
Then we construct a proof system such that its proofs can be translated to ordinary RL proofs of the composed system
(for soundness),
but also such that it allows relatively high-level reasoning about \emph{circular behavior} and \emph{lock-step execution}
(for ease of verification and simplicity of invariants).
We draw our inspiration from the literature on language-independent verification of partial correctness
(\cite{RosuS12oopsla,RosuSCM13lics,StefanescuCMMSR19})
and program equivalence (\cite{CiobacaLRR16,CiobacaLRR14}).
Again, we elaborate on the similarities and differences in \Cref{sec:discussion}. 

\section{Preliminaries}

\subsection{($\mu$-free) Matching Logic}

We work with a variant of matching logic described in
\cite{StefanescuCMMSR19,RosuSCM13lics}.
This particular variant of matching logic is used for reasoning about static properties of program configurations.
There exist newer and more expressive variants of matching logic (\cite{MmL, MLexplained});
we used the older variant in order to be compatible with the literature on reachability logic which uses this variant.

Matching logic \emph{formula} (aka \emph{pattern}) is a first-order logic (FOL) formula which allows terms,
over a signature $\Sigma$, with variables, as nullary predicates.
The satisfaction relation $(M, \gamma, \rho) \vDash \varphi$ between a model $M$, a model element $\gamma \in M$,
an $M$-valuation $\rho$, and a pattern $\varphi$, is defined inductively on the structure of $\varphi$.
The definition is as in FOL; the main difference is the semantics of terms-as-predicates, which is defined by
\begin{equation*}
    (M, \gamma, \rho) \vDash t \iff \gamma = \rho(t) \text{ if t is a term}
\end{equation*}
(where $\rho(t)$ is the homomorphic extension of $\rho$ applied to the term $t$).
A pattern $\varphi$ is \emph{valid in $M$}, written $M \vDash \varphi$, iff $(M, \gamma, \rho) \vDash \varphi$
for every $\gamma$ and $\rho$.
A formal definition is to be found in the Appendix.

We observe that validity of a structureless pattern (that is a pattern without terms-as-predicates) does not depend on the selected model element.
Also, validity of any pattern does not depend on those variables which the pattern does not mention.


\subsection{One-path Reachability Logic}
Reachability logic \cite{StefanescuCMMSR19,RosuS12oopsla} is a formalism for reasoning about partial correctness
of programs in any programming language which has a RL-based formal semantics. The programming language is modelled as a \emph{reachability system}
$\mathcal{S} = (\mathcal{T}, S)$, where $\mathcal{T}$ is a $\Sigma$-algebra
and $S$ is a set of \emph{reachability rules} of the shape $\varphi \Rightarrow^\exists \varphi^\prime$,
where $\varphi$ and $\varphi^\prime$ are matching logic patterns over $\Sigma$.
A reachability system $\mathcal{S} = (\mathcal{T}, S)$ (together with a $\Sigma$-sort $\mathit{Cfg}$)
induces
          a \emph{transition system}
          $(\Tcfg , \Rightarrow_{\mathcal{S}})$,
          where $\gamma \Rightarrow_{\mathcal{S}} \gamma^\prime$
          for $\gamma, \gamma^\prime \in \Tcfg$
          iff there is some rule $\varphi \Rightarrow^\exists \varphi^\prime \in S$
          and some valuation $\rho : \Var \to \mathcal{T}$ with $(\gamma, \rho) \vDash \varphi$
          and $(\gamma^\prime , \rho) \vDash \varphi^\prime$.
A one-path reachability rule $\varphi \Rightarrow^\exists \varphi^\prime$ is \emph{satisfied}
          in a reachability system $\mathcal{S} = (\mathcal{T}, S)$,
          written $\mathcal{S} \vDash_\RL \varphi \Rightarrow^\exists \varphi^\prime$,
          iff for every $\gamma \in \Tcfg$
          such that $\gamma$ terminates in $(\Tcfg, \Rightarrow_{\mathcal{S}})$
          and for any valuation $\rho : \Var \to \mathcal{T}$
          such that $(\gamma, \rho) \vDash \varphi$,
          there exists some $\gamma^\prime \in \Tcfg$
          such that
          $\gamma \Rightarrow^{*}_{\mathcal{S}} \gamma^\prime$
          and $(\gamma^\prime, \rho) \vDash \varphi^\prime$.
A reachability system $(\mathcal{T}, S)$ is \emph{$\epsilon$-free}
          iff for any two configurations $\sigma, \sigma^\prime \in \mathcal{T}_{\mathit{Cfg}}$, if
          $\sigma \Rightarrow_{\mathcal{S}} \sigma^\prime$, then $\sigma \not = \sigma^\prime$;
Reachability logic is equipped with a proof system which derives sequents of the shape
$\mathcal{S}, A, C \vdash_\RL \varphi \Rightarrow^\exists \varphi^\prime$;
the proof system is sound and complete: a RL claim is satisfied in $\mathcal{S}$
iff $\mathcal{S}, \emptyset, \emptyset \vdash_\RL \varphi \Rightarrow^\exists \varphi^\prime$.


\begin{remark}\label{rem:shapeOfReachabilityRules}
For simplicity, we restrict the class of reachability systems we work with to those whose reachability rules
have the shape
%\begin{equation*}
%    \bigvee_{i=1}^{m} (\phi_i \land P_i) \Rightarrow^\exists \exists \vec{Y}.\, \bigvee_{j=1}^{n} (\phi^\prime_j \land P^\prime_j) \, .
%\end{equation*}
\begin{equation*}
    \phi \land P \Rightarrow^\exists \phi^\prime \land P^\prime
\end{equation*}
where $phi \land P$ and $\phi^\prime \land P^\prime$ are constrained terms.
\end{remark}

\begin{remark}\label{rem:noEmptySteps}
We work only with $\epsilon$-free reachability systems.
\end{remark}

\section{Cartesian Reachability Logic}

\subsection{Syntax and Semantics}

Cartesian reachability logic is an extension of (one-path) reachability logic.
Syntactically, we define
\begin{itemize}
    \item 
A \emph{list-pattern} has the shape $[\varphi_1,\ldots,\varphi_k]$,
          where each $\varphi_j$ (for $j \in \{ 1, \ldots, k \} $) is a matching logic pattern.
    \item
          A \emph{constrained list-pattern (CLP)} is a conjunction $\Psi_0 \land P$
          of a list-pattern $\Psi_0$ and a structureless pattern $P$.
    \item
          An \emph{existentially-quantified constrained list-pattern (ECLP)} has the form
          $\exists \vec{Y}.\, \Psi$, where $\Psi$ is a CLP and $\vec{Y}$ is a (possibly empty) list of variables.
    \item
          A \emph{One-Path Cartesian reachability claim of arity $k$} has the shape
          $\Phi \Rightarrow^{c\exists} \Psi$,
          where $\Phi$ is a CLP and $\Psi$ is an ECLP.
\end{itemize}

\begin{definition}[CRL semantics]\label{def:opCRLsemantics}
    A claim
    \begin{equation*}
     [\varphi_1,\ldots,\varphi_k] \land P
     \Rightarrow^{c\exists} \exists \vec{Y}.\, [\varphi^\prime_1,\ldots,\varphi^\prime_k] \land P^\prime
    \end{equation*}
    is \emph{valid} in a reachability system $\mathcal{S} = (\mathcal{T}, S)$,
    written
    \begin{equation*}
        \mathcal{S} \vDash_\CRL [\varphi_1,\ldots,\varphi_k] \land P
     \Rightarrow^{c\exists} \exists \vec{Y}.\, [\varphi^\prime_1,\ldots,\varphi^\prime_k] \land P^\prime \, ,
    \end{equation*}
    iff for all configurations $\gamma_1,\ldots,\gamma_k \in \Tcfg$
    which terminate in $(\Tcfg, \Rightarrow_{\mathcal{S}})$
    and any $\mathcal{T}$-valuation $\rho$,
    whenever $(\gamma_1,\rho) \vDash \varphi_1 \land P$ and \ldots
    and $(\gamma_k,\rho) \vDash \varphi_k \land P$,
    then there exist configurations $\gamma_1^\prime,\ldots,\gamma_k^\prime \in \Tcfg$
    such that $\gamma_1 \Rightarrow^{*}_{\mathcal{S}} \gamma_1^\prime$
    and \ldots and $\gamma_k \Rightarrow^{*}_{\mathcal{S}} \gamma_k^\prime$,
    and there also exists an $\mathcal{T}$-valuation $\rho^\prime$
    satisfying $\rho(v) = \rho^\prime(v)$ for any $v \in \mathit{Var} \setminus \vec{Y}$,
    and
    $(\gamma_1^\prime,\rho^\prime) \vDash \varphi^\prime_1 \land P^\prime$ and \ldots and $(\gamma_k^\prime, \rho^\prime) \vDash \varphi^\prime_k \land P^\prime$.
\end{definition}

We note here that in general, having one valid CRL claim is different from having just $k$ valid RL claims,
because in CRL, the variables are shared across components.
Consider, for example, a reachability system $S_{\mathit{IMP}}$ representing a simple imperative language,
and a program $P \equiv \texttt{while(x > 0)\{ y++; x--;\}}$.
We can let $C(Q, X,Y)$ represent a configuration of a program $Q$ where the program variable $\texttt{x}$ has the value $X$
and the program variable $\texttt{y}$ has the value $Y$;
for example,
\begin{equation*}
 C(Q, X, Y) \equiv \texttt{<k>} Q \texttt{</k><st>(x |-> } X \texttt{)(y |-> } Y \texttt{)</st>}    \, .
\end{equation*}
Then, the proposition
\begin{align*}
 S_{\mathit{IMP}} \vDash_\CRL
&[C(P, X_1, Y_1),C(P, X_2, Y_2)] \land X_1 \leq X_2
\\ \Rightarrow^{c\exists} &
\exists X^\prime_1, Y^\prime_1, X^\prime_2, Y^\prime_2.\,  [C(\epsilon, X^\prime_1, Y^\prime_1), C(\epsilon, X^\prime_2, Y^\prime_2)] \land Y^\prime_1 \leq Y^\prime_2   
\end{align*}
holds iff the program $P$ is monotone (when considering the variable $x$ to be an input, and $y$ to be an output; $\epsilon$ represents an empty program).
One can localize the ``global'' constraints; for example, the above proposition is equivalent to
\begin{align*}
 S_{\mathit{IMP}} \vDash_\CRL
&[C(P, X_1, Y_1),C(P, X_2, Y_2) \land X_1 \leq X_2] 
\\ \Rightarrow^{c\exists} &
\exists X^\prime_1, Y^\prime_1, X^\prime_2, Y^\prime_2.\, [C(\epsilon, X^\prime_1, Y^\prime_1), C(\epsilon, X^\prime_2, Y^\prime_2) \land Y^\prime_1 \leq Y^\prime_2] \, .
\end{align*}
However, if one were to ``split'' the CRL claim into two, the resulting claims would may say something other than monotonicity.
For example, the propositions
\begin{align*}
 S_{\mathit{IMP}} \vDash_\RL
C(P^\prime, X_1, Y_1)
\Rightarrow^{\exists}
\exists X^\prime_1, Y^\prime_1.\, C(\epsilon, X^\prime_1, Y^\prime_1)
\end{align*}
and
\begin{align*}
 S_{\mathit{IMP}} \vDash_\RL
C(P^\prime, X_2, Y_2) \land X_1 \leq X_2] 
 \Rightarrow^{\exists}
\exists X^\prime_2, Y^\prime_2.\, C(\epsilon, X^\prime_2, Y^\prime_2) \land Y^\prime_1 \leq Y^\prime_2
\end{align*}
do \emph{not} hold when $P^\prime \equiv P$: in fact, the second proposition requires the variable $\texttt{y}$ in a resulting configuration
to have greater value then any number, since $Y_1^\prime$ is not existentially quantified in the right side of the claim,
and therefore is implicitly universally quantified.
On the other hand, if we existentiall quantified it, the claim would say nothing about the value of $\texttt{y}$.

However, cartesian reachability logic does extend reachability logic:
\begin{remark}
\Cref{def:opCRLsemantics} extends \Cref{def:oprlSemantics} of \Cref{def:basics}:
if we fix $k=1$, then
\begin{align*}
    (\mathcal{T}, S) \vDash_\CRL
    [\varphi] \land \top  \Rightarrow^{c\exists}
    [\varphi^\prime] \land \top
    \iff
    (\mathcal{T}, S) \vDash_\RL \varphi \Rightarrow^{\exists} \varphi^\prime \, .
\end{align*}
\end{remark}

%\begin{definition}[All-Path Cartesian Reachability Rule]\label{def:apCRLsemantics}
%An all-path Cartesian reachability rule
%$(\varphi_1,\ldots,\varphi_k) \land \varphi \Rightarrow^{c\forall} (\psi_1,\ldots,\psi_k) \land \psi$
%of arity $k$
%is \emph{valid} in a reachability system $\mathcal{S} = (\mathcal{T}, S)$,
%written
%$\mathcal{S} \vDash_\CRL (\varphi_1,\ldots,\varphi_k) \land \varphi \Rightarrow^{c\forall}
%(\psi_1,\ldots,\psi_k) \land \psi$,
%iff for all configurations $\sigma_1,\ldots,\sigma_k \in \Tcfg$ \traian{Why $\sigma$ instead of $\gamma$?}
%and any $\mathcal{T}$-valuation $\rho$,
%whenever $(\sigma_1, \rho) \vDash \varphi_1 \land \varphi$ and \ldots
%and $(\sigma_k, \rho) \vDash \varphi_k \land \varphi$,
%then for every $k$-tuple of complete paths $(\pi_1, \ldots, \pi_k)$
%such that
%$\sigma_1 = \pi_1(0) \land \ldots \land \sigma_k = \pi_k(0)$,
%there exist indices $i_1, \ldots, i_k$ such that
%$(\pi_1(i_1), \rho) \vDash \varphi_1 \land \psi$ and \ldots and $(\pi_k(i_k), \rho) \vDash \varphi_k \land \psi$.
%\end{definition}



We now want to characterize the semantics of cartesian reachability logic in terms of semantics of reachability logic.
To do so, we need
\begin{itemize}
    \item to extend a matching logic signature $\Sigma$ into some $\Sigma^*$;
    \item to transform a reachability-system $\mathcal{S}$ into some extended system $\mathcal{S}^*$; 
    \item to translate a cartesian reachability logic claim $\Psi \Rightarrow^{c\exists} \Psi^\prime$
    into some reachability logic claim $\mathit{flatten}(\Psi) \Rightarrow^{c\exists} \mathit{flatten}(\Psi^\prime)$; and
    \item make sure that the translated claim holds in the extended system iff the original claim holds in the original system.
\end{itemize}
Formally:
\begin{theorem}\label{thm:CRLandRLcorrespondence}
There exist a function $\_^*$ on matching logic signatures,
a (equally-named) function $\_^*$ from reachability systems over $\Sigma$ to reachability systems over $\Sigma^*$,
and a function $\mathit{flatten}$ from ECLPs over $\Sigma$ to matching logic $\Sigma^*$-formulas,
such that
\begin{equation*}
\mathcal{S} \vDash_{\CRL} \Psi \Rightarrow^{c\exists} \Psi^\prime
  \iff \mathcal{S}^* \vDash_\RL \mathit{flatten}(\Psi) \Rightarrow^{c\exists} \mathit{flatten}(\Psi^\prime)
\end{equation*}
\end{theorem}


\subsection{Proof System}

We give Cartesian Reachability Logic a proof system to faciliate mechanical reasoning.
One may ask the question, ``why give CRL a new proof system if one can perform the same reasoning
by means of \Cref{thm:CRLandRLcorrespondence} and the existing proof system of reachability logic?''.
The answer is the following.
When one reduces a CRL goal into RL using \Cref{thm:CRLandRLcorrespondence},
the function $\mathit{flatten}$ appears in the goal.
To perform reasoning using the RL proof system, one then has to either simplify the goal
by unfolding the definition of $\mathit{flatten}$,
or use (and prove) some helper lemmas about the effect of applying RL proof rules
%and other frequently used steps
on RL goals containing $\mathit{flatten}$.
In the first case one lowers the abstraction level and have to reason about matching logic formulas
containing translations of other matching logic formulas into FOL, which then makes RL reasoning more complex.
In the second case, however, one may end up proving lemmas which, when combined, result in a proof system for CRL.

Indeed, the soundness of our proof system (\Cref{fig:CRLproofsystem})
is established by a (meta-)proof which constructs a RL proof from a CRL one (\Cref{lem:CRLalmostSoundness}).

The proof system derives claims of the shape
$\mathcal{S}, \vdash_\CRL \Phi \Downarrow_{C,E} \Psi$,
where $\Phi$ is of the shape
$(\varphi_1, \ldots, \varphi_k) \land P$
and $\Psi$ is of the shape
$\exists \vec{Y}.\, (\varphi^\prime_1, \ldots, \varphi^\prime_k) \land P^\prime$,
where $P,P^\prime$ are structureless FOL formulas
and every $\varphi_i$ is a matching logic pattern.
%and every $\varphi_i$ and $\varphi^\prime_i$ has the structure of
%$\exists x_1,\ldots,x_n. (\phi_1 \land P_1) \lor \ldots (\phi_m \land P_m)$
%and $\exists x^\prime_1,\ldots,x^\prime_{n^\prime}. (\phi^\prime_1 \land P^\prime_1) \lor \ldots (\phi^\prime_m \land P^\prime_m)$, respectively.
The idea is that $P$ is the part of the claim that relates variables from different components.
Initially, the proof starts with the claim
$\mathcal{S} \vdash_\CRL \Phi \Downarrow_{\emptyset, \emptyset} \Psi$.


\begin{figure}
    \centering
    \begin{align*}
    & \prftree[l]{Reflexivity}{\mathcal{S} \vdash_\CRL \Psi \Downarrow_{\emptyset,E} \Psi}
    \end{align*}
    \begin{align*}
    & \prftree[l]{Axiom}{\Psi \in E}{\mathcal{S} \vdash_\CRL \Psi \Downarrow_{C,E} \Psi^\prime}
    \end{align*}
    \begin{align*}
    & \prftree[l]{Reduce}
      {(\mathcal{T}^*, S^* \cup \mathit{flatten}^\exists(E, \Psi^\prime)), \emptyset \vdash_\RL
        \mathit{flatten}^\exists(\Psi, \Psi^\prime) }
      {(\mathcal{T}, S) \vdash_\CRL \Psi \Downarrow_{C,E} \Psi^\prime}
    \end{align*}
    \begin{align*}
    & \prftree[l]{Case}
    { \prfStackPremises
      {\mathcal{S} \vdash_\CRL [\varphi_1, \ldots, \varphi_{i-1}, \varphi_i, \varphi_{i+1}, \ldots, \varphi_k] \land P^\prime \Downarrow_{C, E} \Psi^\prime }
      {\mathcal{S} \vdash_\CRL [\varphi_1, \ldots, \varphi_{i-1}, \psi_i, \varphi_{i+1}, \ldots, \varphi_k] \land P^\prime \Downarrow_{C, E} \Psi^\prime }
    }
    {\mathcal{S} \vdash_\CRL [\varphi_1, \ldots, \varphi_{i-1}, (\varphi_i \lor \psi_i), \varphi_{i+1}, \ldots, \varphi_k] \land P^\prime \Downarrow_{C, E} \Psi^\prime}
    \end{align*}
    \begin{align*}
    & \prftree[l]{Step}
    { \prfStackPremises
       {\varphi \Rightarrow^\exists \varphi^\prime \in S}
       {\mathcal{T} \vDash_\ML \varphi_i \leftrightarrow \varphi \land P^\prime}
       {P^\prime \mbox{ is a structureless FOL formula}}
       {  (\mathcal{T}, S) \vdash_\CRL [\varphi_1, \ldots, \varphi_{i-1}, \varphi^\prime \land P^\prime, \varphi_{i+1}, \ldots, \varphi_k]
          \land P
          \Downarrow_{\emptyset, (C \cup E)} \Psi^\prime
      }
    }
    {(\mathcal{T}, S) \vdash_\CRL [\varphi_1, \ldots, \varphi_{i-1}, \varphi_i, \varphi_{i+1}, \ldots, \varphi_k] \land P \Downarrow_{C, E} \Psi^\prime}
    \end{align*}
    \begin{align*}
    & \prftree[l]{Circularity}
      { \mathcal{S} \vdash_\CRL \Psi \Downarrow_{C \cup \{ \Psi \} , E} \Psi^\prime}
      { \mathcal{S} \vdash_\CRL \Psi \Downarrow_{C, E} \Psi^\prime}
    \end{align*}
    \begin{align*}
    & \prftree[l]{Conseq}
      { \prfStackPremises
        { (\mathcal{T}, S) \vdash_\CRL \Phi^\prime \Downarrow_{C, E} \Psi^\prime}
        { \mathcal{T}^* \vDash_\ML \mathit{flatten}(\Phi) \rightarrow \mathit{flatten}(\Phi^\prime) }
      }
      { (\mathcal{T}, S) \vdash_\CRL \Phi \Downarrow_{C, E} \Psi^\prime}
    \end{align*}
%    \begin{align*}
%    & \prftree[l]{Conseq2}
%      { \prfStackPremises
%        { (\mathcal{T}, S) \vdash_\CRL (\varphi_1, \ldots, \varphi_k) \land P \Downarrow_{C, E} \Psi^\prime}
%        { \mathcal{T} \vDash_\ML \varphi_i \leftrightarrow \psi_i }
%      }
%      { (\mathcal{T}, S) \vdash_\CRL (\varphi_1^\prime, \ldots, \varphi_{i-1}, \varphi_{i}, \varphi_{i+1}, \ldots, \varphi_k^\prime) \land P^\prime \Downarrow_{C, E} \Psi^\prime}
%    \end{align*}

    %\begin{align*}
    %& \prftree[l]{Abstract}
      %{ \prfStackPremises
        %{ X \not\in \mathit{FV}(\Psi^\prime, \varphi_1, \ldots, \varphi_{i-1}, \varphi_{i+1}, \ldots,\varphi_k)
        %}
        %{(\mathcal{T}, S) \vdash_\CRL (\varphi_1, \ldots, \varphi_{i-1}, \varphi_i, \varphi_{i+1}, \ldots, \varphi_k) \land P \Downarrow_{C, E} \Psi^\prime}
      %}
      %{(\mathcal{T}, S) \vdash_\CRL (\varphi_1, \ldots, \varphi_{i-1}, \exists X.\, \varphi_i, \varphi_{i+1}, \ldots, \varphi_k) \land P \Downarrow_{C, E} \Psi^\prime}
    %\end{align*}
    
    \begin{align*}
    & \prftree[l]{Abstract}
      { \prfStackPremises
        { X \not\in \mathit{FV}(\Psi^\prime)
        }
        {(\mathcal{T}, S) \vdash_\CRL \exists \vec{Y}.\, [\varphi_1, \ldots, \varphi_k] \land P \Downarrow_{C, E} \Psi^\prime}
      }
      {(\mathcal{T}, S) \vdash_\CRL \exists X, \vec{Y}.\, [\varphi_1, \ldots, \varphi_k] \land P \Downarrow_{C, E} \Psi^\prime}
    \end{align*}
    \caption{Proof System}
    \label{fig:CRLproofsystem}
\end{figure}



\begin{lemma}\label{lem:CRLalmostSoundness}
    \begin{align*}
        & (\mathcal{T}, S) \vdash_\CRL \Psi \Downarrow_{C,E} \Psi^\prime \implies \\
        &
        (\mathcal{T}^*, S^* \cup \mathit{flatten}^\exists(E, \Psi^\prime)), \mathit{flatten}^\exists(C, \Psi^\prime) \vdash_\RL
          \mathit{flatten}^\exists(\Psi, \Psi^\prime) 
    \end{align*}
\end{lemma}

\begin{theorem}[Proof system soundness]\label{thm:proofsystemSoundness}
\begin{equation*}
    \mathcal{S} \vdash_\CRL \Psi \Downarrow_{\emptyset,\emptyset} \Psi^\prime \implies
    \mathcal{S} \vDash_{\CRL} \Psi \Rightarrow^{c\exists} \Psi^\prime
\end{equation*}
\end{theorem}
\begin{proof}[Proof of \Cref{thm:proofsystemSoundness}]
Assume $\mathcal{S} \vdash_\CRL \Psi \Downarrow_{\emptyset,\emptyset} \Psi^\prime$.
By \Cref{lem:CRLalmostSoundness}, we have $\mathcal{S} \vdash_\RL \mathit{flatten}^\exists(\Psi, \Psi^\prime)$.
By soundness of reachability logic, we have $\mathcal{S} \vDash_\RL \mathit{flatten}^\exists(\Psi, \Psi^\prime)$.
By \Cref{thm:correspondence}, 
we have $\mathcal{S} \vDash_{\CRL} \Psi \Rightarrow^{c\exists} \Psi^\prime$ and we are done.
\end{proof}

\section{Implementation}

\section{Discussion}\label{sec:discussion}

\subsection{Relation to Cartesian Hoare logic}

\subsubsection{(Non)determinism}
We base our work on the \emph{one-path} variant of reachability logic.
Consequently, CRL inherits a known limitation of one-path reachability logic: that the tight correspondence between
one-path RL and Hoare logics is limited to deterministic languages.
However, we would still want to prove the following theorem.
\begin{theorem}
CRL extends CHL on the deterministic fragment of the CHL-supported language.
That is, given any program $P$ in the deterministic fragment of the CHL's imperative language,
a sound reachability-logic formalization (that is, a reachability system) $\mathcal{S}_{\mathit{IMP}}$ of the CHL's imperative language,
and firstorder formulas $\Phi, \Psi$ over variables $\vec{x}_1,\ldots,\vec{x}_k$,
\begin{equation*}
    \vDash_{\mathit{CHL}} ||\Phi||\ P\ ||\Psi||
    \iff
    \mathcal{S}_{\mathit{IMP}} \vDash_\CRL \mathit{tr}(P, \Phi) \Rightarrow^{c\exists} \mathit{tr}(P, \Psi) \, .
\end{equation*}
\end{theorem}
\begin{proof}
Admitted. Use the relationship between one-path CRL and all-path CRL on deterministic languages (TODO).
\end{proof}

\subsubsection{Main Idea and Proof Technique}

Our understanding of the inner workings of CHL is based on the extended, unpublished version (\cite{SousaD16Extended})
of \cite{SousaD16}.
There, the authors define a \emph{linearization operation} on lists of programs, which roughly corresponds to our
\emph{star extension} of the language's semantics.
Then, the authors prove lemmas saying that a CHL triple with a list of programs inside is derivable
in the CHL proof system
if and only if 
a Hoare triple having the same list of programs, but linearized, inside, is derivable;
the "only if" implication corresponds to our \Cref{lem:CRLalmostSoundness}, where we construct
an RL proof from a CRL proof,
while the "if" implication corresponds to our Reduce rule.
Furthermore, in the proof of soundness of CHL, the authors assume soundness of the self-composition technique;
self-composition corresponds to our \emph{star extension} and its soundness to our \Cref{thm:correspondence}.
Finally \cite{SousaD16Extended} assumes soundness and relative completeness of the underling Hoare logic;
similarly, we assume soundness and relative completeness of reachability logic.
However, for completeness, we have to prove that \emph{star extension} preserves decidability.

\subsubsection{Differences}
There are also differences between the CHL and CRL techniques.
First, our proof system has only 8 rules, and they do not mention any programming language construct,
while CHL has 17 rules (not counting the Expand rule), half of which are specific to the underlying language.

Second, there is a redundancy between the language-specific CHL rules and the Hoare logic rules of the
programming language: for example, conditional statement ("if") has (1) a rule in the formal semantics of the language,
(2) a rule in the Hoare logic (not shown in the paper), and (3) a rule in CHL.
When considering that the three rules have to play nice together (that is, CHL and Hoare logic rules have to be sound with respect to the semantics), someone had to think about the conditional statement at least five times .
We consider this to be highly uneconomical
- and the situation
is even worse for the looping construct ("while-with-breaks"), which is supported using additional CHL rules.
In contrast, in the CRL/RL framework, it is enough to design each language construct once - when giving
semantics to it.


Third, in CHL the support for lock-step reasoning is hard-wired into the rules for loops,
while in our framework, lock-step reasoning is not limited to loops, but can support arbitrary sources
of circular behavior - including loops, recursion, gotos.
Therefore, while we are inspired by the \emph{idea} of lock-step execution from \cite{SousaD16},
for the \emph{realization} of this idea we turn to the literature on \emph{equivalence checking}.

\subsection{Relation to semantic-based program equivalence}

TODO

\subsection{Other Related Work}


Also, a game-based technique for verifying software hyperproperties beyond $k$-safety
has been developed in \cite{BeutnerF22}.
This technique works with \emph{symbolic transition systems},
so it already is language-independent \emph{in some sense}. However, it is not clear how to use the technique
with an arbitrary language $L$, without writing a compiler from $L$ to symbolic transition systems first.



\bibliography{bibliography}
\bibliographystyle{plain}

\appendix

\section{Appendix}
\input{proofs}

\end{document}
